{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Data Structures in Java for Smith College This website currently focuses a few weeks into the course I would usually teach, after finishing the pure-Java topics. Most of the content is presented in video format (\ud83d\udcfa); a little over 100 videos with about 6 hours of total runtime. There is some content from earlier in the course, but that content is entirely notes-based (\ud83d\udcd6). Java Notes This section contains a handful of notes useful for when you're \"Getting started with Java\". Java from Python Objects & Classes Using Java's Lists Data Structures Notes I consider stacks and queues to primarily be specific uses of lists -- rather than independent topics. Some of this is a trade-off for time in this course. Stacks & Queues Big-O notation and complexity We use big-O notation to talk about the time-complexity (and very-occasionally the space-complexity) of data structures. These notes provide an intro. Complexity Lists: Linked & Array We typically spend a significant amount of time on lists as the data structure family where we practice implementing every method of a data structure. Fixed Size Lists and ArrayLists Singly Linked-Lists Doubly Linked-Lists Chunky ArrayLists Lists Conclusions Sorting A sorted list can be considered a set data structure, so covering sorting also makes a fair bit of sense -- also it provides motivation for trees and practice with recursion. Sorting (Part 1): Binary Search, IsSorted, BubbleSort Sorting (Part 2): Insertion, Selection and Merge Sort QuickSort Comparison Notes - these notes provide an aside about how to get Java to sort your own classes and objects. Trees Trees are broadly useful and heaps are critical to a number of applications. They also continue the journey of learning to reason about relationships between nodes and data on the way to graphs. Intro to Trees Heaps & HeapSort HashTables HashTables can provide nearly O(1) lookup, insert, and remove by spending some additional space on empty buckets. Hashing, HashTables, HashSets, and HashMaps Algorithms Preview Data structures naturally feeds into algorithms topics, so we cover some of these at the end of this course as a \"What's-next?\" setup. Balancing Tree Algorithms Intro to Graphs & Graph Algorithms","title":"\ud83d\udcd6 About"},{"location":"index.html#data-structures-in-java-for-smith-college","text":"This website currently focuses a few weeks into the course I would usually teach, after finishing the pure-Java topics. Most of the content is presented in video format (\ud83d\udcfa); a little over 100 videos with about 6 hours of total runtime. There is some content from earlier in the course, but that content is entirely notes-based (\ud83d\udcd6).","title":"Data Structures in Java for Smith College"},{"location":"index.html#java-notes","text":"This section contains a handful of notes useful for when you're \"Getting started with Java\". Java from Python Objects & Classes Using Java's Lists","title":"Java Notes"},{"location":"index.html#data-structures-notes","text":"I consider stacks and queues to primarily be specific uses of lists -- rather than independent topics. Some of this is a trade-off for time in this course. Stacks & Queues","title":"Data Structures Notes"},{"location":"index.html#big-o-notation-and-complexity","text":"We use big-O notation to talk about the time-complexity (and very-occasionally the space-complexity) of data structures. These notes provide an intro. Complexity","title":"Big-O notation and complexity"},{"location":"index.html#lists-linked-array","text":"We typically spend a significant amount of time on lists as the data structure family where we practice implementing every method of a data structure. Fixed Size Lists and ArrayLists Singly Linked-Lists Doubly Linked-Lists Chunky ArrayLists Lists Conclusions","title":"Lists: Linked &amp; Array"},{"location":"index.html#sorting","text":"A sorted list can be considered a set data structure, so covering sorting also makes a fair bit of sense -- also it provides motivation for trees and practice with recursion. Sorting (Part 1): Binary Search, IsSorted, BubbleSort Sorting (Part 2): Insertion, Selection and Merge Sort QuickSort Comparison Notes - these notes provide an aside about how to get Java to sort your own classes and objects.","title":"Sorting"},{"location":"index.html#trees","text":"Trees are broadly useful and heaps are critical to a number of applications. They also continue the journey of learning to reason about relationships between nodes and data on the way to graphs. Intro to Trees Heaps & HeapSort","title":"Trees"},{"location":"index.html#hashtables","text":"HashTables can provide nearly O(1) lookup, insert, and remove by spending some additional space on empty buckets. Hashing, HashTables, HashSets, and HashMaps","title":"HashTables"},{"location":"index.html#algorithms-preview","text":"Data structures naturally feeds into algorithms topics, so we cover some of these at the end of this course as a \"What's-next?\" setup. Balancing Tree Algorithms Intro to Graphs & Graph Algorithms","title":"Algorithms Preview"},{"location":"Balancing.html","text":"Balancing Tree Algorithms The goal of this section is not to actually study tree-balancing algorithms (that's an Algorithms topic) but to give a more concrete sense of how those algorithms work. Opinion : If you find yourself heading off to implement a self-balancing binary search tree; do yourself a favor and don't do it . If you just need association, use a hashmap instead. If you do need the ordered-nature, implement a SkipList instead -- for basically the same performance, the code/algorithms are much simpler! (Pugh, 1990) Why we Balance Trees (3:28) Tree Rotations (3:04) AVL Self-Balancing Algorithm Overview (5:11) Red-Black Self-Balancing Algorithm Overview (2:25) Treaps & SkipLists (2:23)","title":"\ud83d\udcfa Balancing Tree Algorithms"},{"location":"Balancing.html#balancing-tree-algorithms","text":"The goal of this section is not to actually study tree-balancing algorithms (that's an Algorithms topic) but to give a more concrete sense of how those algorithms work. Opinion : If you find yourself heading off to implement a self-balancing binary search tree; do yourself a favor and don't do it . If you just need association, use a hashmap instead. If you do need the ordered-nature, implement a SkipList instead -- for basically the same performance, the code/algorithms are much simpler! (Pugh, 1990)","title":"Balancing Tree Algorithms"},{"location":"Balancing.html#why-we-balance-trees-328","text":"","title":"Why we Balance Trees (3:28)"},{"location":"Balancing.html#tree-rotations-304","text":"","title":"Tree Rotations (3:04)"},{"location":"Balancing.html#avl-self-balancing-algorithm-overview-511","text":"","title":"AVL Self-Balancing Algorithm Overview (5:11)"},{"location":"Balancing.html#red-black-self-balancing-algorithm-overview-225","text":"","title":"Red-Black Self-Balancing Algorithm Overview (2:25)"},{"location":"Balancing.html#treaps-skiplists-223","text":"","title":"Treaps &amp; SkipLists (2:23)"},{"location":"ChunkyArrayList.html","text":"Chunky ArrayLists \"Chunky\" ArrayLists are a concept more or less invented by me for instructional purposes. It's an example of a practical improvement (over SLL/DLL) but where the big-O notation doesn't necessarily mirror the practical improvements. It's analagous to a BTree but as a list. Studying this topic was optional in S2020. ChunkyArrayList (what is it?) (3:32) ChunkyArrayList addFront (1:51) ChunkyArrayList removeFront (2:26) ChunkyArrayList addIndex animated (4:46) ChunkyArrayList Complexity Discussion (3:40)","title":"\ud83d\udcfa Chunky ArrayLists"},{"location":"ChunkyArrayList.html#chunky-arraylists","text":"\"Chunky\" ArrayLists are a concept more or less invented by me for instructional purposes. It's an example of a practical improvement (over SLL/DLL) but where the big-O notation doesn't necessarily mirror the practical improvements. It's analagous to a BTree but as a list. Studying this topic was optional in S2020.","title":"Chunky ArrayLists"},{"location":"ChunkyArrayList.html#chunkyarraylist-what-is-it-332","text":"","title":"ChunkyArrayList (what is it?) (3:32)"},{"location":"ChunkyArrayList.html#chunkyarraylist-addfront-151","text":"","title":"ChunkyArrayList addFront (1:51)"},{"location":"ChunkyArrayList.html#chunkyarraylist-removefront-226","text":"","title":"ChunkyArrayList removeFront (2:26)"},{"location":"ChunkyArrayList.html#chunkyarraylist-addindex-animated-446","text":"","title":"ChunkyArrayList addIndex animated (4:46)"},{"location":"ChunkyArrayList.html#chunkyarraylist-complexity-discussion-340","text":"","title":"ChunkyArrayList Complexity Discussion (3:40)"},{"location":"DLL.html","text":"Doubly Linked-Lists Doubly-Linked Lists (DLLs) are an important data structure to study and provide fast access to both the front and back of the lists. DLL: Intro/Symmetry (3:59) DLL size() vs. SLL size() (1:36) DLL isEmpty() quiz solution (2:41) SLL/DLL Complexity Table (2:45)","title":"\ud83d\udcfa Doubly Linked-Lists"},{"location":"DLL.html#doubly-linked-lists","text":"Doubly-Linked Lists (DLLs) are an important data structure to study and provide fast access to both the front and back of the lists.","title":"Doubly Linked-Lists"},{"location":"DLL.html#dll-introsymmetry-359","text":"","title":"DLL: Intro/Symmetry (3:59)"},{"location":"DLL.html#dll-size-vs-sll-size-136","text":"","title":"DLL size() vs. SLL size() (1:36)"},{"location":"DLL.html#dll-isempty-quiz-solution-241","text":"","title":"DLL isEmpty() quiz solution (2:41)"},{"location":"DLL.html#slldll-complexity-table-245","text":"","title":"SLL/DLL Complexity Table (2:45)"},{"location":"FSL.html","text":"Array-Based Lists: FixedSizeList & GrowableList (aka ArrayList) We build up to understanding ArrayLists by thinking about what an Array does and does not give us -- from ArrayWrapper (just an array) to FixedSizeList (with a fill pointer) to ArrayList which also has an exponential growth strategy. What's an ArrayWrapper? (2:45) slideToTheLeft Code Discussion (3:03) ArrayWrapper to FixedSizeList to ArrayList/GrowableList (1:56) FixedSizeList Class Tour (1:47) FixedSizeList Visual/Mental Model (2:19) FixedSizeList removeIndex(2) Visual Example (1:33) FixedSizeList addBack (1:49) FixedSizeList removeIndex Code (2:25) FixedSizeList to ArrayList Plan & Visual (3:28) ArrayList/GrowableList resizeArray (0:58) ArrayList Conclusions & Core Challanges (2:54)","title":"\ud83d\udcfa Array-Based Lists"},{"location":"FSL.html#array-based-lists-fixedsizelist-growablelist-aka-arraylist","text":"We build up to understanding ArrayLists by thinking about what an Array does and does not give us -- from ArrayWrapper (just an array) to FixedSizeList (with a fill pointer) to ArrayList which also has an exponential growth strategy.","title":"Array-Based Lists: FixedSizeList &amp; GrowableList (aka ArrayList)"},{"location":"FSL.html#whats-an-arraywrapper-245","text":"","title":"What's an ArrayWrapper? (2:45)"},{"location":"FSL.html#slidetotheleft-code-discussion-303","text":"","title":"slideToTheLeft Code Discussion (3:03)"},{"location":"FSL.html#arraywrapper-to-fixedsizelist-to-arraylistgrowablelist-156","text":"","title":"ArrayWrapper to FixedSizeList to ArrayList/GrowableList (1:56)"},{"location":"FSL.html#fixedsizelist-class-tour-147","text":"","title":"FixedSizeList Class Tour (1:47)"},{"location":"FSL.html#fixedsizelist-visualmental-model-219","text":"","title":"FixedSizeList Visual/Mental Model (2:19)"},{"location":"FSL.html#fixedsizelist-removeindex2-visual-example-133","text":"","title":"FixedSizeList removeIndex(2) Visual Example (1:33)"},{"location":"FSL.html#fixedsizelist-addback-149","text":"","title":"FixedSizeList addBack (1:49)"},{"location":"FSL.html#fixedsizelist-removeindex-code-225","text":"","title":"FixedSizeList removeIndex Code (2:25)"},{"location":"FSL.html#fixedsizelist-to-arraylist-plan-visual-328","text":"","title":"FixedSizeList to ArrayList Plan &amp; Visual (3:28)"},{"location":"FSL.html#arraylistgrowablelist-resizearray-058","text":"","title":"ArrayList/GrowableList resizeArray (0:58)"},{"location":"FSL.html#arraylist-conclusions-core-challanges-254","text":"","title":"ArrayList Conclusions &amp; Core Challanges (2:54)"},{"location":"Graphs.html","text":"Intro to Graphs & Graph Algorithms The goal of this section of the course is to complete our story-telling about graph-reasoning. We don't study graphs deeply (or have an assignment to implement these algorithms). Opinion : However, the whole point of studying Singly-Linked-Lists, Doubly-Linked-Lists, then Trees is so we can get to Graphs. So I try to give a broad sense of how graphs are important here and how they're used. Algorithms or an AI course will cover graphs far more deeply. Why we study Graphs... (2:38) IsThisWinnable (Recursive) (2:19) IsThisWinnable (Iterative) (2:07) Terminology used in Graph Search (2:13) SpookyMansion: Depth-First-Search (1:36) Depth-First-Search Application: Maze Generation (1:02) Weaknesses of Depth-First-Search (1:38) Breadth-First-Search (2:56) Weight-Based Graph Searching (A*, Shortest-Path-First) (5:18)","title":"\ud83d\udcfa Intro to Graphs & Graph Algorithms"},{"location":"Graphs.html#intro-to-graphs-graph-algorithms","text":"The goal of this section of the course is to complete our story-telling about graph-reasoning. We don't study graphs deeply (or have an assignment to implement these algorithms). Opinion : However, the whole point of studying Singly-Linked-Lists, Doubly-Linked-Lists, then Trees is so we can get to Graphs. So I try to give a broad sense of how graphs are important here and how they're used. Algorithms or an AI course will cover graphs far more deeply.","title":"Intro to Graphs &amp; Graph Algorithms"},{"location":"Graphs.html#why-we-study-graphs-238","text":"","title":"Why we study Graphs... (2:38)"},{"location":"Graphs.html#isthiswinnable-recursive-219","text":"","title":"IsThisWinnable (Recursive) (2:19)"},{"location":"Graphs.html#isthiswinnable-iterative-207","text":"","title":"IsThisWinnable (Iterative) (2:07)"},{"location":"Graphs.html#terminology-used-in-graph-search-213","text":"","title":"Terminology used in Graph Search (2:13)"},{"location":"Graphs.html#spookymansion-depth-first-search-136","text":"","title":"SpookyMansion: Depth-First-Search (1:36)"},{"location":"Graphs.html#depth-first-search-application-maze-generation-102","text":"","title":"Depth-First-Search Application: Maze Generation (1:02)"},{"location":"Graphs.html#weaknesses-of-depth-first-search-138","text":"","title":"Weaknesses of Depth-First-Search (1:38)"},{"location":"Graphs.html#breadth-first-search-256","text":"","title":"Breadth-First-Search (2:56)"},{"location":"Graphs.html#weight-based-graph-searching-a-shortest-path-first-518","text":"","title":"Weight-Based Graph Searching (A*, Shortest-Path-First) (5:18)"},{"location":"HashTables.html","text":"Hashing, HashTables, HashSets, and HashMaps Dictionaries are built out of HashTables in most languages. There's a pretty good reason. As this is probably students' first encounter with the concept of a hash , I also try to give a sense of what these functions are used for when we're not studying hashmaps/sets/tables. What is a hash function? (5:11) Hash Functions in Security/Privacy (2:22) Hash Functions for HashMaps (3:28) HashSet Example (4:30) HashMap Example (1:11) HashMap Internals: Collisions and Load Factor (5:50) HashSet with Fewer Buckets (1:43) HashMap Collision Resolution Strategies (2:21) HashSet with Linear Probing Example (4:56) HashMap Internals: Example Bucket Classes (1:06) Insertion Order: LinkedHashMap and LinkedHashSet (1:15) HashMaps are the best Dictionary (Complexity) (3:25)","title":"\ud83d\udcfa Hashing & HashTables"},{"location":"HashTables.html#hashing-hashtables-hashsets-and-hashmaps","text":"Dictionaries are built out of HashTables in most languages. There's a pretty good reason. As this is probably students' first encounter with the concept of a hash , I also try to give a sense of what these functions are used for when we're not studying hashmaps/sets/tables.","title":"Hashing, HashTables, HashSets, and HashMaps"},{"location":"HashTables.html#what-is-a-hash-function-511","text":"","title":"What is a hash function? (5:11)"},{"location":"HashTables.html#hash-functions-in-securityprivacy-222","text":"","title":"Hash Functions in Security/Privacy (2:22)"},{"location":"HashTables.html#hash-functions-for-hashmaps-328","text":"","title":"Hash Functions for HashMaps (3:28)"},{"location":"HashTables.html#hashset-example-430","text":"","title":"HashSet Example (4:30)"},{"location":"HashTables.html#hashmap-example-111","text":"","title":"HashMap Example (1:11)"},{"location":"HashTables.html#hashmap-internals-collisions-and-load-factor-550","text":"","title":"HashMap Internals: Collisions and Load Factor (5:50)"},{"location":"HashTables.html#hashset-with-fewer-buckets-143","text":"","title":"HashSet with Fewer Buckets (1:43)"},{"location":"HashTables.html#hashmap-collision-resolution-strategies-221","text":"","title":"HashMap Collision Resolution Strategies (2:21)"},{"location":"HashTables.html#hashset-with-linear-probing-example-456","text":"","title":"HashSet with Linear Probing Example (4:56)"},{"location":"HashTables.html#hashmap-internals-example-bucket-classes-106","text":"","title":"HashMap Internals: Example Bucket Classes (1:06)"},{"location":"HashTables.html#insertion-order-linkedhashmap-and-linkedhashset-115","text":"","title":"Insertion Order: LinkedHashMap and LinkedHashSet (1:15)"},{"location":"HashTables.html#hashmaps-are-the-best-dictionary-complexity-325","text":"","title":"HashMaps are the best Dictionary (Complexity) (3:25)"},{"location":"Heaps.html","text":"Heaps & HeapSort Heaps are super-useful for their applications. After we've talked about trees, (specifically BSTs) we get to see that the heap property is simpler to maintain. Heaps vs. Binary Search Trees (3:36) Min-heaps and Max-heaps (1:40) Heaps are stored in ArrayLists (3:05) Heap Insert (1:59) Heap Sift-Up Code (2:10) Heap Remove (Sift-Down) Ex. 1 (1:18) Heap Remove (SiftDown) Ex. 2 (1:18) Heap Sift-Down Code (3:35) HeapSort (4:30) PriorityQueue Complexity (2:13) Heap Applications: Priority Queue (4:15)","title":"\ud83d\udcfa Heaps & HeapSort"},{"location":"Heaps.html#heaps-heapsort","text":"Heaps are super-useful for their applications. After we've talked about trees, (specifically BSTs) we get to see that the heap property is simpler to maintain.","title":"Heaps &amp; HeapSort"},{"location":"Heaps.html#heaps-vs-binary-search-trees-336","text":"","title":"Heaps vs. Binary Search Trees (3:36)"},{"location":"Heaps.html#min-heaps-and-max-heaps-140","text":"","title":"Min-heaps and Max-heaps (1:40)"},{"location":"Heaps.html#heaps-are-stored-in-arraylists-305","text":"","title":"Heaps are stored in ArrayLists (3:05)"},{"location":"Heaps.html#heap-insert-159","text":"","title":"Heap Insert (1:59)"},{"location":"Heaps.html#heap-sift-up-code-210","text":"","title":"Heap Sift-Up Code (2:10)"},{"location":"Heaps.html#heap-remove-sift-down-ex-1-118","text":"","title":"Heap Remove (Sift-Down) Ex. 1 (1:18)"},{"location":"Heaps.html#heap-remove-siftdown-ex-2-118","text":"","title":"Heap Remove (SiftDown) Ex. 2 (1:18)"},{"location":"Heaps.html#heap-sift-down-code-335","text":"","title":"Heap Sift-Down Code (3:35)"},{"location":"Heaps.html#heapsort-430","text":"","title":"HeapSort (4:30)"},{"location":"Heaps.html#priorityqueue-complexity-213","text":"","title":"PriorityQueue Complexity (2:13)"},{"location":"Heaps.html#heap-applications-priority-queue-415","text":"","title":"Heap Applications: Priority Queue (4:15)"},{"location":"Lists.html","text":"Lists Conclusions This section has a bit of list miscellanea that I would usually scatter around the ~4 lectures we use to cover lists. They got their own section here because I was flipping the classroom this Spring. How are loops abstract? Iterators. (8:19) Dealing with Infinite Loops in JUnit and Linked Lists. (5:30) Lists IRL: Where are these data structures found? (4:25)","title":"\ud83d\udcfa Lists Conclusions"},{"location":"Lists.html#lists-conclusions","text":"This section has a bit of list miscellanea that I would usually scatter around the ~4 lectures we use to cover lists. They got their own section here because I was flipping the classroom this Spring.","title":"Lists Conclusions"},{"location":"Lists.html#how-are-loops-abstract-iterators-819","text":"","title":"How are loops abstract? Iterators. (8:19)"},{"location":"Lists.html#dealing-with-infinite-loops-in-junit-and-linked-lists-530","text":"","title":"Dealing with Infinite Loops in JUnit and Linked Lists. (5:30)"},{"location":"Lists.html#lists-irl-where-are-these-data-structures-found-425","text":"","title":"Lists IRL: Where are these data structures found? (4:25)"},{"location":"QuickSort.html","text":"QuickSort QuickSort could have been kept as part of Sorting Lecture #2, but I prefer to give the students only 1 recursive sort at a time to struggle with. Once a student has successfully coded up a recursive merge sort, discussing QuickSort feels much easier. Quick Idea of Quicksort (2:24) Quicksort: Hoare's Partitioning (4:53) Quicksort: Small Example (1:21) QuickSort: Efficiency / Choosing a Pivot (3:45) QuickSort Complexity & IRL (3:13)","title":"\ud83d\udcfa QuickSort"},{"location":"QuickSort.html#quicksort","text":"QuickSort could have been kept as part of Sorting Lecture #2, but I prefer to give the students only 1 recursive sort at a time to struggle with. Once a student has successfully coded up a recursive merge sort, discussing QuickSort feels much easier.","title":"QuickSort"},{"location":"QuickSort.html#quick-idea-of-quicksort-224","text":"","title":"Quick Idea of Quicksort (2:24)"},{"location":"QuickSort.html#quicksort-hoares-partitioning-453","text":"","title":"Quicksort: Hoare's Partitioning (4:53)"},{"location":"QuickSort.html#quicksort-small-example-121","text":"","title":"Quicksort: Small Example (1:21)"},{"location":"QuickSort.html#quicksort-efficiency-choosing-a-pivot-345","text":"","title":"QuickSort: Efficiency / Choosing a Pivot (3:45)"},{"location":"QuickSort.html#quicksort-complexity-irl-313","text":"","title":"QuickSort Complexity &amp; IRL (3:13)"},{"location":"SLL.html","text":"Singly Linked-Lists By this point in the course, we will have reviewed recursion, so that we can think of the concept of \"Structural Recursion\" first shown here with singly-linked-lists, and then again later with trees. SLL: Recursion Quick Review (3:56) SLL: Structural Recursion (6:16) SLL: Overview (2:54) SLL: size() with nodes (4:39) SLL: addFront (5:55) SLL: removeFront (3:35) SLL: addBack (6:31) SLL: getIndex (strategy only) (2:23) SLL: removeBack (strategy only) (3:32) SLL: Loops Quiz Solution (3:31)","title":"\ud83d\udcfa Singly Linked-Lists"},{"location":"SLL.html#singly-linked-lists","text":"By this point in the course, we will have reviewed recursion, so that we can think of the concept of \"Structural Recursion\" first shown here with singly-linked-lists, and then again later with trees.","title":"Singly Linked-Lists"},{"location":"SLL.html#sll-recursion-quick-review-356","text":"","title":"SLL: Recursion Quick Review (3:56)"},{"location":"SLL.html#sll-structural-recursion-616","text":"","title":"SLL: Structural Recursion (6:16)"},{"location":"SLL.html#sll-overview-254","text":"","title":"SLL: Overview (2:54)"},{"location":"SLL.html#sll-size-with-nodes-439","text":"","title":"SLL: size() with nodes (4:39)"},{"location":"SLL.html#sll-addfront-555","text":"","title":"SLL: addFront (5:55)"},{"location":"SLL.html#sll-removefront-335","text":"","title":"SLL: removeFront (3:35)"},{"location":"SLL.html#sll-addback-631","text":"","title":"SLL: addBack (6:31)"},{"location":"SLL.html#sll-getindex-strategy-only-223","text":"","title":"SLL: getIndex (strategy only) (2:23)"},{"location":"SLL.html#sll-removeback-strategy-only-332","text":"","title":"SLL: removeBack (strategy only) (3:32)"},{"location":"SLL.html#sll-loops-quiz-solution-331","text":"","title":"SLL: Loops Quiz Solution (3:31)"},{"location":"Sorting1.html","text":"Sorting (Part 1): Binary Search, IsSorted, BubbleSort At this point in the course, I like to do sorting before trees because it's good to talk about why \"alphabetizing\" data is a good thing to do. So we discuss binary search (closing out our assignment zero discussion of the guessing-game) and then introduce how to check whether a list is sorted, which naturally becomes BubbleSort when we try to fix out-of-order pairs. What is Divide & Conquer? (4:31) Binary Search: The Power (and Why?) of Sorting (3:47) What is a logarithm? Why does it show up in CS? (2:14) IsSorted (intuition / pre-quiz hint) (1:09) From IsSorted to BubbleSort (6:52)","title":"\ud83d\udcfa Sorting (1/2): Binary Search, IsSorted, BubbleSort"},{"location":"Sorting1.html#sorting-part-1-binary-search-issorted-bubblesort","text":"At this point in the course, I like to do sorting before trees because it's good to talk about why \"alphabetizing\" data is a good thing to do. So we discuss binary search (closing out our assignment zero discussion of the guessing-game) and then introduce how to check whether a list is sorted, which naturally becomes BubbleSort when we try to fix out-of-order pairs.","title":"Sorting (Part 1): Binary Search, IsSorted, BubbleSort"},{"location":"Sorting1.html#what-is-divide-conquer-431","text":"","title":"What is Divide &amp; Conquer? (4:31)"},{"location":"Sorting1.html#binary-search-the-power-and-why-of-sorting-347","text":"","title":"Binary Search: The Power (and Why?) of Sorting (3:47)"},{"location":"Sorting1.html#what-is-a-logarithm-why-does-it-show-up-in-cs-214","text":"","title":"What is a logarithm? Why does it show up in CS? (2:14)"},{"location":"Sorting1.html#issorted-intuition-pre-quiz-hint-109","text":"","title":"IsSorted (intuition / pre-quiz hint) (1:09)"},{"location":"Sorting1.html#from-issorted-to-bubblesort-652","text":"","title":"From IsSorted to BubbleSort (6:52)"},{"location":"Sorting2.html","text":"Sorting (Part 2): Insertion, Selection and Merge Sort This lecture introduces some other sorts (for some sort of breadth) but focuses on Merge Sort, which ( Opinion ) is the only sort any practicing Computer Scientist really needs to know deeply, since its pieces are so critical to big-data algorithms. Most of the other sorts are neat, but don't have applications to other domains. Insertion Sort (5:29) Selection Sort (4:44) MergeSort combineTwoSortedLists (Ex. 1) (3:24) MergeSort combineTwoSortedLists (pseudocode) (1:32) MergeSort intuition (from combineTwoSortedLists) (1:36) MergeSort: Iterative (3:30) MergeSort: Recursive (3:16) MergeSort: Small Example (5:04) MergeSort: Big Example & Complexity (9:08)","title":"\ud83d\udcfa Sorting (2/2): Insertion, Selection and Merge Sort"},{"location":"Sorting2.html#sorting-part-2-insertion-selection-and-merge-sort","text":"This lecture introduces some other sorts (for some sort of breadth) but focuses on Merge Sort, which ( Opinion ) is the only sort any practicing Computer Scientist really needs to know deeply, since its pieces are so critical to big-data algorithms. Most of the other sorts are neat, but don't have applications to other domains.","title":"Sorting (Part 2): Insertion, Selection and Merge Sort"},{"location":"Sorting2.html#insertion-sort-529","text":"","title":"Insertion Sort (5:29)"},{"location":"Sorting2.html#selection-sort-444","text":"","title":"Selection Sort (4:44)"},{"location":"Sorting2.html#mergesort-combinetwosortedlists-ex-1-324","text":"","title":"MergeSort combineTwoSortedLists (Ex. 1) (3:24)"},{"location":"Sorting2.html#mergesort-combinetwosortedlists-pseudocode-132","text":"","title":"MergeSort combineTwoSortedLists (pseudocode) (1:32)"},{"location":"Sorting2.html#mergesort-intuition-from-combinetwosortedlists-136","text":"","title":"MergeSort intuition (from combineTwoSortedLists) (1:36)"},{"location":"Sorting2.html#mergesort-iterative-330","text":"","title":"MergeSort: Iterative (3:30)"},{"location":"Sorting2.html#mergesort-recursive-316","text":"","title":"MergeSort: Recursive (3:16)"},{"location":"Sorting2.html#mergesort-small-example-504","text":"","title":"MergeSort: Small Example (5:04)"},{"location":"Sorting2.html#mergesort-big-example-complexity-908","text":"","title":"MergeSort: Big Example &amp; Complexity (9:08)"},{"location":"Trees.html","text":"Intro to Trees This is a very broad intro to Trees, which come up all over in CS, so I try to emphasize that even though you'll probably never write a BST and you'll probably only use it through the Map interface, trees come up throughout many other applications and therefore they're worth learning about. What is a Tree? (5:25) Tree Terminology (2:14) Tree Node Definition (1:41) Tree Node Definition Drawing (1:05) Trees to TreeSet and TreeMap (4:48) Complexity in TreeSet and TreeMap (5:17) Balancing and Tree Operation Complexity (4:15) What is a Binary Tree? (+BTree) (6:41) Tree Traverals and Math Expression Example (6:45) Code for In-Order Tree Traversal (3:41) Code for Tree Traversals (all at once) (4:43) Applications of Trees (4:58) Trees Recap (1:26)","title":"\ud83d\udcfa Intro to Trees"},{"location":"Trees.html#intro-to-trees","text":"This is a very broad intro to Trees, which come up all over in CS, so I try to emphasize that even though you'll probably never write a BST and you'll probably only use it through the Map interface, trees come up throughout many other applications and therefore they're worth learning about.","title":"Intro to Trees"},{"location":"Trees.html#what-is-a-tree-525","text":"","title":"What is a Tree? (5:25)"},{"location":"Trees.html#tree-terminology-214","text":"","title":"Tree Terminology (2:14)"},{"location":"Trees.html#tree-node-definition-141","text":"","title":"Tree Node Definition (1:41)"},{"location":"Trees.html#tree-node-definition-drawing-105","text":"","title":"Tree Node Definition Drawing (1:05)"},{"location":"Trees.html#trees-to-treeset-and-treemap-448","text":"","title":"Trees to TreeSet and TreeMap (4:48)"},{"location":"Trees.html#complexity-in-treeset-and-treemap-517","text":"","title":"Complexity in TreeSet and TreeMap (5:17)"},{"location":"Trees.html#balancing-and-tree-operation-complexity-415","text":"","title":"Balancing and Tree Operation Complexity (4:15)"},{"location":"Trees.html#what-is-a-binary-tree-btree-641","text":"","title":"What is a Binary Tree? (+BTree) (6:41)"},{"location":"Trees.html#tree-traverals-and-math-expression-example-645","text":"","title":"Tree Traverals and Math Expression Example (6:45)"},{"location":"Trees.html#code-for-in-order-tree-traversal-341","text":"","title":"Code for In-Order Tree Traversal (3:41)"},{"location":"Trees.html#code-for-tree-traversals-all-at-once-443","text":"","title":"Code for Tree Traversals (all at once) (4:43)"},{"location":"Trees.html#applications-of-trees-458","text":"","title":"Applications of Trees (4:58)"},{"location":"Trees.html#trees-recap-126","text":"","title":"Trees Recap (1:26)"},{"location":"comparison.html","text":"Comparison in Java We sort and compare items as humans because it helps us find things faster. Consider the following objects: List<Book> books = new ArrayList<>(); books.add(new Book(\"Pride and Prejudice\", \"Austen, Jane\", 1813)); books.add(new Book(\"Emma\", \"Austen, Jane\", 1815)); books.add(new Book(\"Frankenstein\", \"Shelley, Mary\", 1818)); They are of class Book , which looks roughly like this: public class Book { String title; String author; int publicationYear; public Book(String title, String author, int publicationYear) { this.title = title; this.author = author; this.publicationYear = publicationYear; } // ... methods ... } Print these books To move along our example, we'll need to be able to print an object of the Book class, so we'll override Java's toString() method. @Override public String toString() { return \"**\" + this.title + \"**\" + \" by \" + this.author + \" (\" + this.publicationYear + \")\"; } Now if we wrap up our main method with a System.out.println(books); , we'll get the following output: [**Pride and Prejudice** by Austen, Jane (1813), **Emma** by Austen, Jane (1815), **Frankenstein** by Shelley, Mary (1818)] Sort these books If I ask you to sort these books, perhaps you do so by author , or by title , or by publicationYear . All the fields of this class are sortable. Maybe you ask me a follow-up question to determine how I want them sorted. In fact, that's exactly what Java does. If we add a sort statement before printing, it tells us it doesn't know how we want to compare book objects. Collections.sort(books); The output is not particularly friendly. Comparison.java:30: error: no suitable method found for sort(List<Book>) Collections.sort(books); ^ method Collections.<T#1>sort(List<T#1>) is not applicable (inference variable T#1 has incompatible bounds equality constraints: Book lower bounds: Comparable<? super T#1>) method Collections.<T#2>sort(List<T#2>,Comparator<? super T#2>) is not applicable (cannot infer type-variable(s) T#2 (actual and formal argument lists differ in length)) where T#1,T#2 are type-variables: T#1 extends Comparable<? super T#1> declared in method <T#1>sort(List<T#1>) T#2 extends Object declared in method <T#2>sort(List<T#2>,Comparator<? super T#2>) 1 error Basically, this boils down to needing a Comparator<T> or a Comparable<T> . But what are those? Java classes for Sorting What is a Comparable<T> ? Comparable is a Java interface which can be implemented on a class to define the default order of a class. Maybe you have a User class in your application, and you always want to sort them by their String username . public class User implements Comparable<User> { String username; // ... et. cetera ... /** Compare this User to another. */ int compare(User other) { return this.username.compareTo(other.username); } } Often Comparable<T> makes sense for your objects. Here, the T is not a class inside this class (as it is in List<T> ) but actually it is the name of the class you are making Comparable . Note that there are some advanced situations where you might make a class Comparable to another class besides itself, but it would be a super -class of the current class. With this definition in place, we can call Java's sorting methods: List<User> users = //... Collections.sort(listOfUsers); What is a Comparator<T> ? Sometimes there is not an obvious default order for a class. Let's go back to our book example. public class Book { String title; String author; int publicationYear; // ... snip ... } We may want to sort by title at one moment, then later by author , and then later by publicationYear . With only Comparable , we would need to have 3 different Book classes and we would need to shuffle data in and out. Instead, we can make three Comparator classes that go with the Book class. public class Book { String title; String author; int publicationYear; // ... snip ... /** This class lets us sort Books by title. */ static class TitleCmp implements Comparator<Book> { public int compare(Book left, Book right) { return left.title.compareTo(right.title); } } } With a Comparator defined, we can then sort a list of books with that specific Comparator object. List<Book> books = //... Collections.sort(books, new Book.TitleCmp()); System.out.println(books); We now get books alphabetically by title: [**Emma** by Austen, Jane (1815), **Frankenstein** by Shelley, Mary (1818), **Pride and Prejudice** by Austen, Jane (1813)] Java 8 Lambdas (easier Comparators!). In Java 8, a simpler way to create objects from classes that only define 1 method was introduced: lambda syntax. For instance, we can print out all three orders concisely as: Collections.sort(books, (left, right) -> left.author.compareTo(right.author)); System.out.println(books); Collections.sort(books, (left, right) -> left.title.compareTo(right.title)); System.out.println(books); Collections.sort(books, (left, right) -> Integer.compare(left.publicationYear, right.publicationYear)); System.out.println(books); But we have to know that we're defining a Comparator and it's method takes two arguments. Nicely enough, Java will figure out the rest. Comparable vs. Comparator TL;DR: Here's a table comparing them: Method Left Right Comments int compare(T left, T right) left right Comparators take in two arguments. int compare(T other) this other Comparables take in one argument and compare to themselves. Why do compare methods return an int ? Compare methods are a replacement for < , > , and == for your new class, and therefore have three possible outputs. Situation Output a < b a negative number a == b 0 a > b a positive numbers If you think about integer subtraction, int compare(int a, int b) { return a - b; } performs appropriately, returning numbers that are interpretable as all three comparisons! Sorting in the other direction: Because it's an integer, we can also sort in the opposite direction, descending (a.ka., Z to A, biggest to smallest, etc.) by writing a Comparator or Comparable that takes the negative of an existing one. We also have access to Collections.reverse(list) . Why is comparing Strings fairly slow? When you have other types, you tend to be fancier. For instance, here's a sketch of how to compare two strings: class StrCmp implements Comparator<String> { int compare(String left, String right) { int N = left.length(); // Can't be equal if they have different sizes. if (right.length() != N) { // Shorter strings first: return Integer.compare(N, right.length()); } // If they have the same size... for (int i = 0; i < N; i++) { char lc = left.charAt(i); char rc = right.charAt(i); // If any character is different, exit immediately with which direction! if (lc != rc) { return Character.compare(lc, rc); } } // If we got to the end, they must be the same. return 0; } } Never use this code; trust that java.lang.String is a Comparable already and just call left.compareTo(right); as we've been doing earlier. Sorting IRL: How do I compare...? Class/Type Method byte Byte.compare(x, y) short Short.compare(x, y) int Integer.compare(x, y) long Long.compare(x, y) char Character.compare(x, y) String x.compareTo(y) Comparable<T> x.compareTo(y) Your class here. Define it yourself.","title":"\ud83d\udcd6Aside: Comparison"},{"location":"comparison.html#comparison-in-java","text":"We sort and compare items as humans because it helps us find things faster. Consider the following objects: List<Book> books = new ArrayList<>(); books.add(new Book(\"Pride and Prejudice\", \"Austen, Jane\", 1813)); books.add(new Book(\"Emma\", \"Austen, Jane\", 1815)); books.add(new Book(\"Frankenstein\", \"Shelley, Mary\", 1818)); They are of class Book , which looks roughly like this: public class Book { String title; String author; int publicationYear; public Book(String title, String author, int publicationYear) { this.title = title; this.author = author; this.publicationYear = publicationYear; } // ... methods ... }","title":"Comparison in Java"},{"location":"comparison.html#print-these-books","text":"To move along our example, we'll need to be able to print an object of the Book class, so we'll override Java's toString() method. @Override public String toString() { return \"**\" + this.title + \"**\" + \" by \" + this.author + \" (\" + this.publicationYear + \")\"; } Now if we wrap up our main method with a System.out.println(books); , we'll get the following output: [**Pride and Prejudice** by Austen, Jane (1813), **Emma** by Austen, Jane (1815), **Frankenstein** by Shelley, Mary (1818)]","title":"Print these books"},{"location":"comparison.html#sort-these-books","text":"If I ask you to sort these books, perhaps you do so by author , or by title , or by publicationYear . All the fields of this class are sortable. Maybe you ask me a follow-up question to determine how I want them sorted. In fact, that's exactly what Java does. If we add a sort statement before printing, it tells us it doesn't know how we want to compare book objects. Collections.sort(books); The output is not particularly friendly. Comparison.java:30: error: no suitable method found for sort(List<Book>) Collections.sort(books); ^ method Collections.<T#1>sort(List<T#1>) is not applicable (inference variable T#1 has incompatible bounds equality constraints: Book lower bounds: Comparable<? super T#1>) method Collections.<T#2>sort(List<T#2>,Comparator<? super T#2>) is not applicable (cannot infer type-variable(s) T#2 (actual and formal argument lists differ in length)) where T#1,T#2 are type-variables: T#1 extends Comparable<? super T#1> declared in method <T#1>sort(List<T#1>) T#2 extends Object declared in method <T#2>sort(List<T#2>,Comparator<? super T#2>) 1 error Basically, this boils down to needing a Comparator<T> or a Comparable<T> . But what are those?","title":"Sort these books"},{"location":"comparison.html#java-classes-for-sorting","text":"","title":"Java classes for Sorting"},{"location":"comparison.html#what-is-a-comparablet","text":"Comparable is a Java interface which can be implemented on a class to define the default order of a class. Maybe you have a User class in your application, and you always want to sort them by their String username . public class User implements Comparable<User> { String username; // ... et. cetera ... /** Compare this User to another. */ int compare(User other) { return this.username.compareTo(other.username); } } Often Comparable<T> makes sense for your objects. Here, the T is not a class inside this class (as it is in List<T> ) but actually it is the name of the class you are making Comparable . Note that there are some advanced situations where you might make a class Comparable to another class besides itself, but it would be a super -class of the current class. With this definition in place, we can call Java's sorting methods: List<User> users = //... Collections.sort(listOfUsers);","title":"What is a Comparable&lt;T&gt;?"},{"location":"comparison.html#what-is-a-comparatort","text":"Sometimes there is not an obvious default order for a class. Let's go back to our book example. public class Book { String title; String author; int publicationYear; // ... snip ... } We may want to sort by title at one moment, then later by author , and then later by publicationYear . With only Comparable , we would need to have 3 different Book classes and we would need to shuffle data in and out. Instead, we can make three Comparator classes that go with the Book class. public class Book { String title; String author; int publicationYear; // ... snip ... /** This class lets us sort Books by title. */ static class TitleCmp implements Comparator<Book> { public int compare(Book left, Book right) { return left.title.compareTo(right.title); } } } With a Comparator defined, we can then sort a list of books with that specific Comparator object. List<Book> books = //... Collections.sort(books, new Book.TitleCmp()); System.out.println(books); We now get books alphabetically by title: [**Emma** by Austen, Jane (1815), **Frankenstein** by Shelley, Mary (1818), **Pride and Prejudice** by Austen, Jane (1813)]","title":"What is a Comparator&lt;T&gt;?"},{"location":"comparison.html#java-8-lambdas-easier-comparators","text":"In Java 8, a simpler way to create objects from classes that only define 1 method was introduced: lambda syntax. For instance, we can print out all three orders concisely as: Collections.sort(books, (left, right) -> left.author.compareTo(right.author)); System.out.println(books); Collections.sort(books, (left, right) -> left.title.compareTo(right.title)); System.out.println(books); Collections.sort(books, (left, right) -> Integer.compare(left.publicationYear, right.publicationYear)); System.out.println(books); But we have to know that we're defining a Comparator and it's method takes two arguments. Nicely enough, Java will figure out the rest.","title":"Java 8 Lambdas (easier Comparators!)."},{"location":"comparison.html#comparable-vs-comparator","text":"TL;DR: Here's a table comparing them: Method Left Right Comments int compare(T left, T right) left right Comparators take in two arguments. int compare(T other) this other Comparables take in one argument and compare to themselves.","title":"Comparable vs. Comparator"},{"location":"comparison.html#why-do-compare-methods-return-an-int","text":"Compare methods are a replacement for < , > , and == for your new class, and therefore have three possible outputs. Situation Output a < b a negative number a == b 0 a > b a positive numbers If you think about integer subtraction, int compare(int a, int b) { return a - b; } performs appropriately, returning numbers that are interpretable as all three comparisons!","title":"Why do compare methods return an int?"},{"location":"comparison.html#sorting-in-the-other-direction","text":"Because it's an integer, we can also sort in the opposite direction, descending (a.ka., Z to A, biggest to smallest, etc.) by writing a Comparator or Comparable that takes the negative of an existing one. We also have access to Collections.reverse(list) .","title":"Sorting in the other direction:"},{"location":"comparison.html#why-is-comparing-strings-fairly-slow","text":"When you have other types, you tend to be fancier. For instance, here's a sketch of how to compare two strings: class StrCmp implements Comparator<String> { int compare(String left, String right) { int N = left.length(); // Can't be equal if they have different sizes. if (right.length() != N) { // Shorter strings first: return Integer.compare(N, right.length()); } // If they have the same size... for (int i = 0; i < N; i++) { char lc = left.charAt(i); char rc = right.charAt(i); // If any character is different, exit immediately with which direction! if (lc != rc) { return Character.compare(lc, rc); } } // If we got to the end, they must be the same. return 0; } } Never use this code; trust that java.lang.String is a Comparable already and just call left.compareTo(right); as we've been doing earlier.","title":"Why is comparing Strings fairly slow?"},{"location":"comparison.html#sorting-irl-how-do-i-compare","text":"Class/Type Method byte Byte.compare(x, y) short Short.compare(x, y) int Integer.compare(x, y) long Long.compare(x, y) char Character.compare(x, y) String x.compareTo(y) Comparable<T> x.compareTo(y) Your class here. Define it yourself.","title":"Sorting IRL: How do I compare...?"},{"location":"complexity.html","text":"Complexity Before we get too far into the data structures section of our course, we need a new tool: we need a formal way of comparing the efficiency of different pieces of code. To say that another way, let's say we come up with two different ways to implement a list. Which one is better? How do we know? Better for which methods? We call this new tool Complexity . Another word for complexity might be difficulty : how difficult is a particular solution. Note that we're entirely uninterested in how difficult it was for us humans, we only care about our computer. How difficult is it for the computer to run our code? Add Five to a Number Let's say we have to write a method that adds five to its input and returns the output. We come up with three solutions to this problem: addFiveA , addFiveB , and addFiveC . Take a moment to read all of them. // This option is about as short as we can get it. public static int addFiveA(int x) { return x + 5; } // What if we introduce a variable for output? public static int addFiveB(int x) { int output = x + 5; return output; } // Recall that output++; is a shorthand for output = output + 1; public static int addFiveC(int x) { int output = x; output++; output++; output++; output++; output++; return output; } Which solution do you prefer? Why? Why did we decide to make these methods static? A Strategy: Count Lines of Code One thing you might have thought of is that addFiveA is only 1 line of code: a return statement, whereas addFiveB takes two lines of code and addFiveC is 7 lines of code. As a counter-argument to this strategy, consider the following re-writing of addFiveA and addFiveB . public static int addFiveA2(int x) { // did you know you can have semicolons alone on a line in Java? ; return x + 5; } public static int addFiveC2(int x) { int output = x; output++; output++; output++; output++; output++; return output; } I just cheated your measure. Now addFiveA2 is five lines of code and addFiveC2 is only one. The computer has to do the same amount of work as the original addFiveA but now we have a comment, a blank line, and a return statement that's all spread out, and it uses five times as many lines as addFiveC2 . Lines of code is not a robust measure of coding complexity. If you ever have a manager who requires you to write a certain number of lines of code each day; now you can explain why that's not a fair measure! Strategy: Count Semicolons \"Eureka!\", you say. \"Your evil tricks have led me to the solution. What if we count semicolons instead of lines. Better than that: what if we count non-empty statements.\" This turns out to be a pretty good strategy. Now we can compare these methods together. You diligently create the following table. Method Name Useful Semicolons addFiveA 1 addFiveB 2 addFiveC 7 Clearly, addFiveA is the best of these methods, because it has the fewest useful semicolons. Count the sum of the numbers from 1 to N Suppose you want to count all the numbers from 1 to N, including N. You quickly code up the following iterative solution: public static int sumSequence1(int n) { int sum = 0; for (int i=1; i<=n; i++) { sum += i; } return sum; } How do we count the semicolons in a for-loop? Is there a recursive solution? Can you write it? This is a classical problem, as it turns out, for which there is an easier algorithm. This is asking for a Triangular Number , and so given any value n we can compute this by directly calcuating it, rather than summing the intermediate numbers. Triangular numbers will come up again later when we study sorting. Imagine an list algorithm that solves 1 item at a time in a list, until it gets to all \\\\(n\\\\) items in the list. // Formula for triangular numbers: https://en.wikipedia.org/wiki/Triangular_number public static int sumSequence2(int n) { return (n * (n - 1)) / 2; } // Again, with steps broken out. public static int sumSequence3(int n) { int result = n * (n - 1) return result / 2; } Writing a quick main method lets us check that the behavior indeed appears to be the same: // 1 + 2 + 3 == 6 System.out.println(\"S1(3) = \"+sumSequence(3)); System.out.println(\"S2(3) = \"+sumSequence2(3)); // 1 + 2 + .. + 10 == 55 System.out.println(\"S1(10) = \"+sumSequence(10)); System.out.println(\"S2(10) = \"+sumSequence2(10)); This causes some problems for our notion of complexity. When we simulate the for-loop from sumSequence1 in our head, we find out that it depends on n , the size of the input. // The for-loop from sumSequence1, but spread-out with labels. for ( int i=1; // A: the initializer i<=n; // B: the loop-check i++ // C: the step-statement ) { sum += i; // D: the loop body } We then track each of the loop pieces independently: - The initializer: A, runs only once. - The loop-check: B, runs \\(n+1\\) times. It runs before the loop, and then at every step through the loop. - The step-statment: C, runs \\(n-1\\) times. It only runs when the loop-check returns true after the first time through the loop body. - The body of the loop: D, runs \\(n\\) times. Woah. That's a lot of work. There are two other semicolons in the original method, so that brings us to: \\( (n+1) + (n-1) + n + 2 \\) or \\( 3n + 2 \\) Method Name Useful Semicolons sumSequence1 \\( 3n + 2 \\) sumSequence2 \\( 1 \\) sumSequence3 \\( 2 \\) In this instance, no matter what value \\( n \\) takes, we should always prefer sumSequence2 . But this gives us a hint for comparisons that really matter: sumSequence1 is dramatically worse than sumSequence2 (from a complexity point-of-view) because it depends on \\( n \\), the input itself. sumSequence3 is worse than sumSequence2 , but not significantly, when \\(n\\) is large. Big-O notation: What does significant mean? The time complexity of a method or procedure is always defined in terms of the size of its input , which is notated as \\(n\\). And it is always a function, e.g., \\(f(n) = 3n + 2\\) or \\(f(n) = n^3 + n\\). You may have noticed that actually counting the semicolons in a particular example is quite difficult and tedious. Little stylistic differences, (e.g., do you create a helper variable) appear to matter ( sumSequence2 vs. sumSequence3 ). For this reason, we typically use so-called Big-O Notation when we discuss complexity. It allows us to remove the insignificant differences from our notation. If your Calculus background is strong (you are comfortable reading limits), enjoy the formal definition section of Big-O from Wikipedia. If not, consider the following examples and high-level discussion of what Big-O let's us do. \\(O(f(n)) = g(n)\\) where \\(g(n)\\) captures the behavior of \\(f(n)\\) for really big \\(n\\). When powers compete, the biggest power wins, and you ignore coefficients. - \\(O(n^3 + n^2 + 7) = O(n^3)\\) - \\(O(n^3 + 9000n^2) = O(n^3)\\) - \\(O(n^3 + 9000n^{3.14}) = O(n^{3.14})\\) It may help to remember that numbers, like \\(7\\) are equivalent to \\(7n^0\\), and so they have the lowest power, usually. You don't often see negative powers: \\(O(n^{-k})\\) ; that would be code that takes less time as the input gets bigger, which isn't very common. Some functions you have seen before have an ordering, bigger on the left, smaller on the right. O(n!) > O(2^n) > O(n^k) > O(n^2) > O(n\\log(n)) > O(n) > O(\\log(n)) > O(1) When we get back to sorting, we will consider triangle numbers and assign big-O notation to them. What about calling methods? We have defined complexity by counting semicolons, but what happens when you call another method? Nothing changes: the complexity of a method hidden by a call is still part of the behavior of the method calling it -- those semicolons/statements are still used. What about sometimes? Assuming random number generation is \\(O(1)\\), what happens if sometimes we use a good algorithm and sometimes we use a bad algorithm? public static int sumSequenceMaybe(int n) { // 50% of the time, use the closed form, else use the loop. if (ThreadLocalRandom.current().nextBoolean()) { return (n * (n - 1)) / 2; } else { int sum = 0; for (int i=1; i<=n; i++) { sum += i; } return sum; } } 50% of the time, we have an \\(O(1)\\) solution to this problem, and 50% of the time we have an \\(O(n)\\) solution to this problem. Giving that information precisely is the clearest way to describe this method. But, usually computer scientists are concerned with the worst-case scenario: we would mark this method as \\(O(n)\\). If you're a glass-half-empty kind of person, this makes you happy. If not, sometimes we also discuss best-case or average-case complexity. Big-O notation can refer to worst-case, best-case, or average-case complexity. If not stated, we will be discussing worst-case complexity, but everyone has their own standards that matter. When in doubt, just ask! Conclusion Theoretical Complexity is a broad topic and is still an open a research area. We have described complexity as being \"like counting semicolons\" along with Big-O notation to provide a general tool to discuss which functions or methods are most efficient, but we have done so quite informally here.","title":"\ud83d\udcd6 Complexity"},{"location":"complexity.html#complexity","text":"Before we get too far into the data structures section of our course, we need a new tool: we need a formal way of comparing the efficiency of different pieces of code. To say that another way, let's say we come up with two different ways to implement a list. Which one is better? How do we know? Better for which methods? We call this new tool Complexity . Another word for complexity might be difficulty : how difficult is a particular solution. Note that we're entirely uninterested in how difficult it was for us humans, we only care about our computer. How difficult is it for the computer to run our code?","title":"Complexity"},{"location":"complexity.html#add-five-to-a-number","text":"Let's say we have to write a method that adds five to its input and returns the output. We come up with three solutions to this problem: addFiveA , addFiveB , and addFiveC . Take a moment to read all of them. // This option is about as short as we can get it. public static int addFiveA(int x) { return x + 5; } // What if we introduce a variable for output? public static int addFiveB(int x) { int output = x + 5; return output; } // Recall that output++; is a shorthand for output = output + 1; public static int addFiveC(int x) { int output = x; output++; output++; output++; output++; output++; return output; } Which solution do you prefer? Why? Why did we decide to make these methods static?","title":"Add Five to a Number"},{"location":"complexity.html#a-strategy-count-lines-of-code","text":"One thing you might have thought of is that addFiveA is only 1 line of code: a return statement, whereas addFiveB takes two lines of code and addFiveC is 7 lines of code. As a counter-argument to this strategy, consider the following re-writing of addFiveA and addFiveB . public static int addFiveA2(int x) { // did you know you can have semicolons alone on a line in Java? ; return x + 5; } public static int addFiveC2(int x) { int output = x; output++; output++; output++; output++; output++; return output; } I just cheated your measure. Now addFiveA2 is five lines of code and addFiveC2 is only one. The computer has to do the same amount of work as the original addFiveA but now we have a comment, a blank line, and a return statement that's all spread out, and it uses five times as many lines as addFiveC2 . Lines of code is not a robust measure of coding complexity. If you ever have a manager who requires you to write a certain number of lines of code each day; now you can explain why that's not a fair measure!","title":"A Strategy: Count Lines of Code"},{"location":"complexity.html#strategy-count-semicolons","text":"\"Eureka!\", you say. \"Your evil tricks have led me to the solution. What if we count semicolons instead of lines. Better than that: what if we count non-empty statements.\" This turns out to be a pretty good strategy. Now we can compare these methods together. You diligently create the following table. Method Name Useful Semicolons addFiveA 1 addFiveB 2 addFiveC 7 Clearly, addFiveA is the best of these methods, because it has the fewest useful semicolons.","title":"Strategy: Count Semicolons"},{"location":"complexity.html#count-the-sum-of-the-numbers-from-1-to-n","text":"Suppose you want to count all the numbers from 1 to N, including N. You quickly code up the following iterative solution: public static int sumSequence1(int n) { int sum = 0; for (int i=1; i<=n; i++) { sum += i; } return sum; } How do we count the semicolons in a for-loop? Is there a recursive solution? Can you write it? This is a classical problem, as it turns out, for which there is an easier algorithm. This is asking for a Triangular Number , and so given any value n we can compute this by directly calcuating it, rather than summing the intermediate numbers. Triangular numbers will come up again later when we study sorting. Imagine an list algorithm that solves 1 item at a time in a list, until it gets to all \\\\(n\\\\) items in the list. // Formula for triangular numbers: https://en.wikipedia.org/wiki/Triangular_number public static int sumSequence2(int n) { return (n * (n - 1)) / 2; } // Again, with steps broken out. public static int sumSequence3(int n) { int result = n * (n - 1) return result / 2; } Writing a quick main method lets us check that the behavior indeed appears to be the same: // 1 + 2 + 3 == 6 System.out.println(\"S1(3) = \"+sumSequence(3)); System.out.println(\"S2(3) = \"+sumSequence2(3)); // 1 + 2 + .. + 10 == 55 System.out.println(\"S1(10) = \"+sumSequence(10)); System.out.println(\"S2(10) = \"+sumSequence2(10)); This causes some problems for our notion of complexity. When we simulate the for-loop from sumSequence1 in our head, we find out that it depends on n , the size of the input. // The for-loop from sumSequence1, but spread-out with labels. for ( int i=1; // A: the initializer i<=n; // B: the loop-check i++ // C: the step-statement ) { sum += i; // D: the loop body } We then track each of the loop pieces independently: - The initializer: A, runs only once. - The loop-check: B, runs \\(n+1\\) times. It runs before the loop, and then at every step through the loop. - The step-statment: C, runs \\(n-1\\) times. It only runs when the loop-check returns true after the first time through the loop body. - The body of the loop: D, runs \\(n\\) times. Woah. That's a lot of work. There are two other semicolons in the original method, so that brings us to: \\( (n+1) + (n-1) + n + 2 \\) or \\( 3n + 2 \\) Method Name Useful Semicolons sumSequence1 \\( 3n + 2 \\) sumSequence2 \\( 1 \\) sumSequence3 \\( 2 \\) In this instance, no matter what value \\( n \\) takes, we should always prefer sumSequence2 . But this gives us a hint for comparisons that really matter: sumSequence1 is dramatically worse than sumSequence2 (from a complexity point-of-view) because it depends on \\( n \\), the input itself. sumSequence3 is worse than sumSequence2 , but not significantly, when \\(n\\) is large.","title":"Count the sum of the numbers from 1 to N"},{"location":"complexity.html#big-o-notation-what-does-significant-mean","text":"The time complexity of a method or procedure is always defined in terms of the size of its input , which is notated as \\(n\\). And it is always a function, e.g., \\(f(n) = 3n + 2\\) or \\(f(n) = n^3 + n\\). You may have noticed that actually counting the semicolons in a particular example is quite difficult and tedious. Little stylistic differences, (e.g., do you create a helper variable) appear to matter ( sumSequence2 vs. sumSequence3 ). For this reason, we typically use so-called Big-O Notation when we discuss complexity. It allows us to remove the insignificant differences from our notation. If your Calculus background is strong (you are comfortable reading limits), enjoy the formal definition section of Big-O from Wikipedia. If not, consider the following examples and high-level discussion of what Big-O let's us do. \\(O(f(n)) = g(n)\\) where \\(g(n)\\) captures the behavior of \\(f(n)\\) for really big \\(n\\). When powers compete, the biggest power wins, and you ignore coefficients. - \\(O(n^3 + n^2 + 7) = O(n^3)\\) - \\(O(n^3 + 9000n^2) = O(n^3)\\) - \\(O(n^3 + 9000n^{3.14}) = O(n^{3.14})\\) It may help to remember that numbers, like \\(7\\) are equivalent to \\(7n^0\\), and so they have the lowest power, usually. You don't often see negative powers: \\(O(n^{-k})\\) ; that would be code that takes less time as the input gets bigger, which isn't very common. Some functions you have seen before have an ordering, bigger on the left, smaller on the right. O(n!) > O(2^n) > O(n^k) > O(n^2) > O(n\\log(n)) > O(n) > O(\\log(n)) > O(1) When we get back to sorting, we will consider triangle numbers and assign big-O notation to them.","title":"Big-O notation: What does significant mean?"},{"location":"complexity.html#what-about-calling-methods","text":"We have defined complexity by counting semicolons, but what happens when you call another method? Nothing changes: the complexity of a method hidden by a call is still part of the behavior of the method calling it -- those semicolons/statements are still used.","title":"What about calling methods?"},{"location":"complexity.html#what-about-sometimes","text":"Assuming random number generation is \\(O(1)\\), what happens if sometimes we use a good algorithm and sometimes we use a bad algorithm? public static int sumSequenceMaybe(int n) { // 50% of the time, use the closed form, else use the loop. if (ThreadLocalRandom.current().nextBoolean()) { return (n * (n - 1)) / 2; } else { int sum = 0; for (int i=1; i<=n; i++) { sum += i; } return sum; } } 50% of the time, we have an \\(O(1)\\) solution to this problem, and 50% of the time we have an \\(O(n)\\) solution to this problem. Giving that information precisely is the clearest way to describe this method. But, usually computer scientists are concerned with the worst-case scenario: we would mark this method as \\(O(n)\\). If you're a glass-half-empty kind of person, this makes you happy. If not, sometimes we also discuss best-case or average-case complexity. Big-O notation can refer to worst-case, best-case, or average-case complexity. If not stated, we will be discussing worst-case complexity, but everyone has their own standards that matter. When in doubt, just ask!","title":"What about sometimes?"},{"location":"complexity.html#conclusion","text":"Theoretical Complexity is a broad topic and is still an open a research area. We have described complexity as being \"like counting semicolons\" along with Big-O notation to provide a general tool to discuss which functions or methods are most efficient, but we have done so quite informally here.","title":"Conclusion"},{"location":"java-from-python.html","text":"Java from Python When students first come to Java from Python, they are usually a little overwhelmed. There's so much more to type to get anything done! One day, the benefits of learning Java will catch up to you. Some programmers never quite forgive Java for their instruction in it or the sometimes large amounts of code they must write to explain simple things to the computer. However, I promise you: someday you will return to code that you (or someone else) have written late at night for a deadline. You may not have seen this code in months or even years. On that day, languages that are more explicit, like Java are going to be easier to read than languages like Python. Until then, come with me on this journey into being more specific. Java requires classes and objects In Python, we could just drop code into a .py file and get going. Any statements we wrote would be executed when we run the file or import it. Maybe later in our classes we were taught to organize our code like the following: # in main.py: def main(): # do the real work here ... if __name__ == '__main__': main() In python code, you can develop methods called pineapple , apple , and orange and put them in the apple.py file. Nobody's stopping you, even though you should really put it in a file called fruit.py . Java is a little more strict. If we want to have a class called Pineapple , it must be in a file called Pineapple.java . // In Pineapple.java public class Pineapple { public static void main(String[] args) { System.out.println(\"Pineapple is a fruit (I hope).\"); } } For now, we will just think of everything above as a template: // In MYCLASS.java public class MYCLASS { public static void main(String[] args) { // Do MYCLASS stuff. } } Every time we run code, we want to wrap it in a template like this. Although not required, we always want to pick a name for MYCLASS that is capitalized -- this is a \"convention\" in Java, so whenever you see a capitalized word, you can be pretty sure it is a class and not another kind of variable or a method. Variables have types In python, we were able to introduce variables at any point, with any name, and for any kind of value. x = 7 print(x) x = \"Seven\" print(x) Java will get mad at us for trying to do the same sequence of statements: it won't let us confuse ourselves (or our readers!) by having multiple different kinds of values in the same variable. Because x is declared to have an integer (or int ) in it, we can only put other integers in it! // We need to put the type in front of our name: int x = 7; System.out.println(x); x = \"Seven\"; // error: incompatible types: String cannot be converted to int. System.out.println(x); x = 8; // This will work! System.out.println(x); Types go before variable names. // When creating classes: VariableType variableName = new VariableType(); // When dealing with primitives, you often don't use the new keyword. int intName = 7; double doubleName = 3.5; String message = \"Hello World!\"; Numeric Types: int vs. double Going back to our example of int x , there is a distinction between types of numbers that Java calls to our attention. // We need to put the type in front of our name: int x = 7; System.out.println(x); x = 8; // This will work! System.out.println(x); x = 9.1; // error: incompatible types: possible lossy conversion from double to int System.out.println(x); In python, we could seamlessly move between numbers with decimals, and those without, but we had to be careful with division. Java makes us be careful when we create the variable. So what's a double and what's an int ? For a short answer, a double is where we store fractional numbers and those with fractional components, and it even supports exponential notation: 1.5, 0.0, 1e7, -2e3 (this is the same as in Python). An int or integer, on the other hand, only stores whole numbers: 0, 1, 10, -57, 65000 . When you divide integer values together, the decimal remainder disappears and the number is rounded down: System.out.println(7/2); // you'd think: 3.5, but prints: 3 System.out.println(1/2); // you'd think: 0.5, but prints: 0 So if you care about fractions, use a double . If you don't care, use an int . We will mostly only see double values when we do graphics. Beware of fractional numbers and equality! Never ever ever use equality on fractional numbers ( double variables). This is not an issue specific to Java, but it is possible you were never shown this in Python. if 0.1 * 3 == 0.3: print(\"Math works correctly!\") else: print(\"Math does not work!\", 0.3, 0.1 * 3) # Sadly, this prints: Math does not work 0.3 0.30000000000000004 The same problem exists in Java: if (0.1 * 3 == 0.3) { System.out.println(\"Math works correctly!\"); } else { // Hmm: we use + to combine strings here in print, rather than a comma: System.out.println(\"Math does not work! 0.1 * 3 = \" + (0.1 * 3)); } In all cases the way to correct this check is to use math expressions. Instead of comparing x = y directly, do something like this: |x-y| < \\epsilon Where you need to pick a small number, e.g., \\(\\epsilon = 0.0001\\) that represents the level of error you will tolerate. Exponents, powers, and Math Switching from Python to Java has a few little traps. One of them is the power operator. In python, you can raise a number to a power using the ** operator. In both Python and Java, the ^ operator does not perform the power operation: Power works in Python, caret does not. print(2 ** 8) # 256 print(2 ^ 8) # 10 Java doesn't have a power operator, but a static method that exists on the Math class: System.out.println(Math.pow(2, 8)); // 256.0 // This is not a power! System.out.println(2 ^ 8); // 10 Aside: What is an XOR? What's XOR? Both Python and Java agree: 2 ^ 8 == 10 and that's not what we expected from calculators and math class. But what is it? It turns out it is binary exclusive or or the XOR operator. To understand it's behavior we need to know our binary numbers: Decimal Number Binary Number 0 0000 1 0001 2 0010 3 0011 4 0100 5 0101 6 0110 7 0111 8 1000 9 1001 10 1010 11 1011 12 1100 13 1101 14 1110 15 1111 16 10000 .. .. // In binary: 0b0010 ^ 0b1000 == 0b1010; // In decimal: 2 ^ 8 == 10; XOR looks at each \"bit\" set and creates a result where the bits are set if either of the inputs have a 1 but not both. (either-OR, but not both is why we call it eXclusive OR ) java.lang.Math docs There are other methods on Java's Math class that you may find handy, much like Python's math . A full list can be found as on the java.lang.Math JavaDoc System.out.println(Math.abs(-7)); // prints: 7 System.out.println(Math.round(9.1)); // prints: 9 System.out.println(Math.round(9.5)); // prints: 10 System.out.println(Math.round(9.6)); // prints: 10 Methods have input and output types We used to call these functions, but since they must be in a class in Java, we call them methods . Method syntax In python, making a method that multiplies a number by seven is fairly short: def multiply_by_seven(x): return x * 7 Strangely, the above method works on all sorts of things: print(multiply_by_seven(3)) # prints: 21 print(multiply_by_seven(\"<3\")) # prints: <3<3<3<3<3<3<3 print(multiply_by_seven(3.1)) # prints: 21.7 In Java, we must mark the return types, and each of those functions would have to be written separately. // For integers: public static int multiplyBySevenA(int x) { return x * 7; } // For doubles: public static double multiplyBySevenB(double x) { return x * 7.0; } // For strings: public static String multiplyBySevenC(String input) { String output = \"\"; for (int i=0; i<7; i++) { output += input; } return output; } Although it may seem tedious; you probably didn't expect that our multiply_by_seven could be used in 3 ways (at least!). Java makes you be more precise and explicit. You've got to say what you mean and mean what you say . Loops Review There's a children's \"game\" that goes as follows: Pete and Repeat walk into a bar. Pete leaves. Who's left? Repeat. Pete and Repeat walk into a bar. Pete leaves. Who's left? ... Everytime your poor friend says \"Repeat\", the instigator would tell the story again! We've seen while and for loops in Python (and in Java in the previous sections), but let's look at them a little closer. While Loops We saw a while-loop in the GuessingGame example, and these are typically used to construct infinite loops, or to loop until a condition is satisfied. They are very useful when asking for user input: int guess = 0; while(guess != 13) { System.out.println(\"Type 13 to escape this loop: \"); try { guess = scanner.nextInt(); } catch (Exception err) { String whatYouSaid = scanner.nextLine().trim(); System.out.println(\"Please enter a valid number! You said '\" + whatYouSaid + \"' but I don't understand.\"); // Continue takes us around the loop again. continue; } } System.out.println(\"Congratulations; you typed in the magic number!\"); We can also use while loops to build the kinds of things we do in for-loops: int x = 0; while (x < 10) { System.out.println(x); x += 1; } Does the the code snippet with the while loop above print 10? Numerical-For Loops When we worked with Python, if we wanted to loop over a bunch of numbers, the range builtin was our friend: # forward, regular: for i in range(10): print(i) # 0,1,2,3,4,5,6,7,8,9 # customize start=2 and step=3 for i in range(2,10,3): print(i) # 2,5,8 # go backwards: for i in range(10,0,-1): print(i) # 10,9,8,7,6,5,4,3,2,1 Java gives us a for loop with three pieces: a start, a while, and a step. This is a parallel to the range we used to use in python: // forward, regular: for (int i = 0; i < 10; i++) { System.out.println(i); // 0,1,2,3,4,5,6,7,8,9 } // customize start=2, step=3: for (int i = 2; i < 10; i += 3) { System.out.println(i); // 2,5,8 } // go backwards: for (int i = 10; i > 0; i -= 1) { System.out.println(i); // 10,9,8,7,6,5,4,3,2,1 } Collection-For Loops Python has another kind of for-loop: the collection for-loop. for x in [1,7,4,2,1]: print(x) And so does Java. We will talk about Java's collections in much more detail later, but: // import: java.util.Arrays so we can quickly make a list: for (int x : Arrays.asList(1,7,4,2,1)) { System.out.println(x) } Instead of the keyword in that python used, Java uses the : and still requires a type for our loop variable ( x here). If-Statements and Decisions We need to be able to make decisions based on user input, the output of computations or really anything else that comes up in a program. With enough if-statements, you can call your program artificial intelligence or AI. if (success) { System.out.println(\"Everything went as planned.\"); } else { System.out.println(\"I've got some bad news.\"); } Things to notice: in Java, you need parentheses and the curly-braces in order to have if-statements. If, Else If, and Else In python, we can nest else statements to handle a large number of values. if x == 1: print(\"One\") elif x == 2: print(\"Two\") elif x == 3: print(\"Three\") elif x == 4: print(\"Four\") else: print(\"Too big!\") Python has this weird elif keyword that's a portmanteau of else and if . Java just uses the two words directly: if (x == 1) { System.out.println(\"One\"); } else if (x == 2) { System.out.println(\"Two\"); } else if (x == 3) { System.out.println(\"Three\"); } else if (x == 4) { System.out.println(\"Four\"); } else { System.out.println(\"Too big!\"); } Again, sprinkle parentheses and curly-braces to make it Java. Boolean Operators and Rules Thinking about if statements tends to lead us to what can be said in if-statements. It turns out that there's a variable type: boolean that holds either true or false which is exactly like the True and False you would have seen in python. In addition, there are operators just for boolean values: (NOT: ! ), (AND: && ), and (OR || ). If you've taken a logic class or seen these truth tables before, you know what's coming. Not provides us the opposite of a given value: !true is the same as false , and !false is the same as true . Read the exclamation point as the word \"not\". And and or combine two boolean variables, and there are only four possible combinations, so we're just going to list them out: x y AND x && y OR x || y false false false false true false false true false true false true true true true true Think of AND as a pessimist: it's not happy unless both sides are true . Think of OR as an optimist: as soon as it sees one true (in either position) it's pretty happy. What's (true || false) && false ? What's (true || false) || false ? What's !(true || false) || false ? We can express numeric ranges as an AND. Legal guesses to our 1..100 guessing game (including 1, excluding 100) which we sometimes express in math class as: 1 \\leq x < 100 Must be broken into two pieces in Java. All of the following statements are equivalent: guess >= 1 && guess < 100 guess > 0 && guess < 100 guess > 0 && guess <= 99 0 < guess && guess < 100 1 <= guess && guess < 100 If we use an OR by accident, suddenly the statements are true no matter what value guess takes: guess >= 1 || guess < 100 Just because (by virtue of guess actually being a number) it must be either greater than 1 (including 100, 101, 102, ...) or less than 100 (including 0, -1, -2, ...). Addition / Subtraction shortcuts Something else you might have seen me do in Java is use a shortcut for addition or subtraction that isn't legal in Python. In Python we can do either of the following to look up the value of x , add 1 and store it back in x : # full intention: x = x + 1 # shortcut: x += 1 It turns out, in Java (and C and a few others...), we can do one more shortcut that means the same thing: // full intention: x = x + 1; // shortcut: x += 1; // even shorter: x++; // postfix ++x; // prefix There are shortcuts for subtraction as well: // full intention: x = x - 1; // shortcut: x -= 1; // even shorter: x--; // postfix --x; // prefix Prefix vs. Postfix Aside There are some subtle differences between prefix and postfix, but you need not worry about them in the official work of this class. We can write a program to investigate... A Java program to distinguish between pre-and-post operations: // Start at any value: int x = 7; // Postfix uses the value before changing it: System.out.println(x++); // prints: 7 System.out.println(x); // prints: 8 System.out.println(x--); // prints: 8 System.out.println(x); // prints: 7 // Prefix uses the value after changing it: System.out.println(++x); // prints: 8 System.out.println(x); // prints: 8 System.out.println(--x); // prints: 7 System.out.println(x); // prints: 7 I consider these operators to be useful tricks: not to be preferred over comments and clear code. I use ``x++`` in for loops because it's shorter (``++x`` would work as well, too). Exercises Write an absolute value method. Print lyrics to the \"Happy Birthday\" song.","title":"\ud83d\udcd6 Java from Python"},{"location":"java-from-python.html#java-from-python","text":"When students first come to Java from Python, they are usually a little overwhelmed. There's so much more to type to get anything done! One day, the benefits of learning Java will catch up to you. Some programmers never quite forgive Java for their instruction in it or the sometimes large amounts of code they must write to explain simple things to the computer. However, I promise you: someday you will return to code that you (or someone else) have written late at night for a deadline. You may not have seen this code in months or even years. On that day, languages that are more explicit, like Java are going to be easier to read than languages like Python. Until then, come with me on this journey into being more specific.","title":"Java from Python"},{"location":"java-from-python.html#java-requires-classes-and-objects","text":"In Python, we could just drop code into a .py file and get going. Any statements we wrote would be executed when we run the file or import it. Maybe later in our classes we were taught to organize our code like the following: # in main.py: def main(): # do the real work here ... if __name__ == '__main__': main() In python code, you can develop methods called pineapple , apple , and orange and put them in the apple.py file. Nobody's stopping you, even though you should really put it in a file called fruit.py . Java is a little more strict. If we want to have a class called Pineapple , it must be in a file called Pineapple.java . // In Pineapple.java public class Pineapple { public static void main(String[] args) { System.out.println(\"Pineapple is a fruit (I hope).\"); } } For now, we will just think of everything above as a template: // In MYCLASS.java public class MYCLASS { public static void main(String[] args) { // Do MYCLASS stuff. } } Every time we run code, we want to wrap it in a template like this. Although not required, we always want to pick a name for MYCLASS that is capitalized -- this is a \"convention\" in Java, so whenever you see a capitalized word, you can be pretty sure it is a class and not another kind of variable or a method.","title":"Java requires classes and objects"},{"location":"java-from-python.html#variables-have-types","text":"In python, we were able to introduce variables at any point, with any name, and for any kind of value. x = 7 print(x) x = \"Seven\" print(x) Java will get mad at us for trying to do the same sequence of statements: it won't let us confuse ourselves (or our readers!) by having multiple different kinds of values in the same variable. Because x is declared to have an integer (or int ) in it, we can only put other integers in it! // We need to put the type in front of our name: int x = 7; System.out.println(x); x = \"Seven\"; // error: incompatible types: String cannot be converted to int. System.out.println(x); x = 8; // This will work! System.out.println(x);","title":"Variables have types"},{"location":"java-from-python.html#types-go-before-variable-names","text":"// When creating classes: VariableType variableName = new VariableType(); // When dealing with primitives, you often don't use the new keyword. int intName = 7; double doubleName = 3.5; String message = \"Hello World!\";","title":"Types go before variable names."},{"location":"java-from-python.html#numeric-types-int-vs-double","text":"Going back to our example of int x , there is a distinction between types of numbers that Java calls to our attention. // We need to put the type in front of our name: int x = 7; System.out.println(x); x = 8; // This will work! System.out.println(x); x = 9.1; // error: incompatible types: possible lossy conversion from double to int System.out.println(x); In python, we could seamlessly move between numbers with decimals, and those without, but we had to be careful with division. Java makes us be careful when we create the variable.","title":"Numeric Types: int vs. double"},{"location":"java-from-python.html#so-whats-a-double-and-whats-an-int","text":"For a short answer, a double is where we store fractional numbers and those with fractional components, and it even supports exponential notation: 1.5, 0.0, 1e7, -2e3 (this is the same as in Python). An int or integer, on the other hand, only stores whole numbers: 0, 1, 10, -57, 65000 . When you divide integer values together, the decimal remainder disappears and the number is rounded down: System.out.println(7/2); // you'd think: 3.5, but prints: 3 System.out.println(1/2); // you'd think: 0.5, but prints: 0 So if you care about fractions, use a double . If you don't care, use an int . We will mostly only see double values when we do graphics.","title":"So what's a double and what's an int?"},{"location":"java-from-python.html#beware-of-fractional-numbers-and-equality","text":"Never ever ever use equality on fractional numbers ( double variables). This is not an issue specific to Java, but it is possible you were never shown this in Python. if 0.1 * 3 == 0.3: print(\"Math works correctly!\") else: print(\"Math does not work!\", 0.3, 0.1 * 3) # Sadly, this prints: Math does not work 0.3 0.30000000000000004 The same problem exists in Java: if (0.1 * 3 == 0.3) { System.out.println(\"Math works correctly!\"); } else { // Hmm: we use + to combine strings here in print, rather than a comma: System.out.println(\"Math does not work! 0.1 * 3 = \" + (0.1 * 3)); } In all cases the way to correct this check is to use math expressions. Instead of comparing x = y directly, do something like this: |x-y| < \\epsilon Where you need to pick a small number, e.g., \\(\\epsilon = 0.0001\\) that represents the level of error you will tolerate.","title":"Beware of fractional numbers and equality!"},{"location":"java-from-python.html#exponents-powers-and-math","text":"Switching from Python to Java has a few little traps. One of them is the power operator. In python, you can raise a number to a power using the ** operator. In both Python and Java, the ^ operator does not perform the power operation: Power works in Python, caret does not. print(2 ** 8) # 256 print(2 ^ 8) # 10 Java doesn't have a power operator, but a static method that exists on the Math class: System.out.println(Math.pow(2, 8)); // 256.0 // This is not a power! System.out.println(2 ^ 8); // 10","title":"Exponents, powers, and Math"},{"location":"java-from-python.html#aside-what-is-an-xor","text":"What's XOR? Both Python and Java agree: 2 ^ 8 == 10 and that's not what we expected from calculators and math class. But what is it? It turns out it is binary exclusive or or the XOR operator. To understand it's behavior we need to know our binary numbers: Decimal Number Binary Number 0 0000 1 0001 2 0010 3 0011 4 0100 5 0101 6 0110 7 0111 8 1000 9 1001 10 1010 11 1011 12 1100 13 1101 14 1110 15 1111 16 10000 .. .. // In binary: 0b0010 ^ 0b1000 == 0b1010; // In decimal: 2 ^ 8 == 10; XOR looks at each \"bit\" set and creates a result where the bits are set if either of the inputs have a 1 but not both. (either-OR, but not both is why we call it eXclusive OR )","title":"Aside: What is an XOR?"},{"location":"java-from-python.html#javalangmath-docs","text":"There are other methods on Java's Math class that you may find handy, much like Python's math . A full list can be found as on the java.lang.Math JavaDoc System.out.println(Math.abs(-7)); // prints: 7 System.out.println(Math.round(9.1)); // prints: 9 System.out.println(Math.round(9.5)); // prints: 10 System.out.println(Math.round(9.6)); // prints: 10","title":"java.lang.Math docs"},{"location":"java-from-python.html#methods-have-input-and-output-types","text":"We used to call these functions, but since they must be in a class in Java, we call them methods .","title":"Methods have input and output types"},{"location":"java-from-python.html#method-syntax","text":"In python, making a method that multiplies a number by seven is fairly short: def multiply_by_seven(x): return x * 7 Strangely, the above method works on all sorts of things: print(multiply_by_seven(3)) # prints: 21 print(multiply_by_seven(\"<3\")) # prints: <3<3<3<3<3<3<3 print(multiply_by_seven(3.1)) # prints: 21.7 In Java, we must mark the return types, and each of those functions would have to be written separately. // For integers: public static int multiplyBySevenA(int x) { return x * 7; } // For doubles: public static double multiplyBySevenB(double x) { return x * 7.0; } // For strings: public static String multiplyBySevenC(String input) { String output = \"\"; for (int i=0; i<7; i++) { output += input; } return output; } Although it may seem tedious; you probably didn't expect that our multiply_by_seven could be used in 3 ways (at least!). Java makes you be more precise and explicit. You've got to say what you mean and mean what you say .","title":"Method syntax"},{"location":"java-from-python.html#loops-review","text":"There's a children's \"game\" that goes as follows: Pete and Repeat walk into a bar. Pete leaves. Who's left? Repeat. Pete and Repeat walk into a bar. Pete leaves. Who's left? ... Everytime your poor friend says \"Repeat\", the instigator would tell the story again! We've seen while and for loops in Python (and in Java in the previous sections), but let's look at them a little closer.","title":"Loops Review"},{"location":"java-from-python.html#while-loops","text":"We saw a while-loop in the GuessingGame example, and these are typically used to construct infinite loops, or to loop until a condition is satisfied. They are very useful when asking for user input: int guess = 0; while(guess != 13) { System.out.println(\"Type 13 to escape this loop: \"); try { guess = scanner.nextInt(); } catch (Exception err) { String whatYouSaid = scanner.nextLine().trim(); System.out.println(\"Please enter a valid number! You said '\" + whatYouSaid + \"' but I don't understand.\"); // Continue takes us around the loop again. continue; } } System.out.println(\"Congratulations; you typed in the magic number!\"); We can also use while loops to build the kinds of things we do in for-loops: int x = 0; while (x < 10) { System.out.println(x); x += 1; } Does the the code snippet with the while loop above print 10?","title":"While Loops"},{"location":"java-from-python.html#numerical-for-loops","text":"When we worked with Python, if we wanted to loop over a bunch of numbers, the range builtin was our friend: # forward, regular: for i in range(10): print(i) # 0,1,2,3,4,5,6,7,8,9 # customize start=2 and step=3 for i in range(2,10,3): print(i) # 2,5,8 # go backwards: for i in range(10,0,-1): print(i) # 10,9,8,7,6,5,4,3,2,1 Java gives us a for loop with three pieces: a start, a while, and a step. This is a parallel to the range we used to use in python: // forward, regular: for (int i = 0; i < 10; i++) { System.out.println(i); // 0,1,2,3,4,5,6,7,8,9 } // customize start=2, step=3: for (int i = 2; i < 10; i += 3) { System.out.println(i); // 2,5,8 } // go backwards: for (int i = 10; i > 0; i -= 1) { System.out.println(i); // 10,9,8,7,6,5,4,3,2,1 }","title":"Numerical-For Loops"},{"location":"java-from-python.html#collection-for-loops","text":"Python has another kind of for-loop: the collection for-loop. for x in [1,7,4,2,1]: print(x) And so does Java. We will talk about Java's collections in much more detail later, but: // import: java.util.Arrays so we can quickly make a list: for (int x : Arrays.asList(1,7,4,2,1)) { System.out.println(x) } Instead of the keyword in that python used, Java uses the : and still requires a type for our loop variable ( x here).","title":"Collection-For Loops"},{"location":"java-from-python.html#if-statements-and-decisions","text":"We need to be able to make decisions based on user input, the output of computations or really anything else that comes up in a program. With enough if-statements, you can call your program artificial intelligence or AI. if (success) { System.out.println(\"Everything went as planned.\"); } else { System.out.println(\"I've got some bad news.\"); } Things to notice: in Java, you need parentheses and the curly-braces in order to have if-statements.","title":"If-Statements and Decisions"},{"location":"java-from-python.html#if-else-if-and-else","text":"In python, we can nest else statements to handle a large number of values. if x == 1: print(\"One\") elif x == 2: print(\"Two\") elif x == 3: print(\"Three\") elif x == 4: print(\"Four\") else: print(\"Too big!\") Python has this weird elif keyword that's a portmanteau of else and if . Java just uses the two words directly: if (x == 1) { System.out.println(\"One\"); } else if (x == 2) { System.out.println(\"Two\"); } else if (x == 3) { System.out.println(\"Three\"); } else if (x == 4) { System.out.println(\"Four\"); } else { System.out.println(\"Too big!\"); } Again, sprinkle parentheses and curly-braces to make it Java.","title":"If, Else If, and Else"},{"location":"java-from-python.html#boolean-operators-and-rules","text":"Thinking about if statements tends to lead us to what can be said in if-statements. It turns out that there's a variable type: boolean that holds either true or false which is exactly like the True and False you would have seen in python. In addition, there are operators just for boolean values: (NOT: ! ), (AND: && ), and (OR || ). If you've taken a logic class or seen these truth tables before, you know what's coming. Not provides us the opposite of a given value: !true is the same as false , and !false is the same as true . Read the exclamation point as the word \"not\". And and or combine two boolean variables, and there are only four possible combinations, so we're just going to list them out: x y AND x && y OR x || y false false false false true false false true false true false true true true true true Think of AND as a pessimist: it's not happy unless both sides are true . Think of OR as an optimist: as soon as it sees one true (in either position) it's pretty happy. What's (true || false) && false ? What's (true || false) || false ? What's !(true || false) || false ? We can express numeric ranges as an AND. Legal guesses to our 1..100 guessing game (including 1, excluding 100) which we sometimes express in math class as: 1 \\leq x < 100 Must be broken into two pieces in Java. All of the following statements are equivalent: guess >= 1 && guess < 100 guess > 0 && guess < 100 guess > 0 && guess <= 99 0 < guess && guess < 100 1 <= guess && guess < 100 If we use an OR by accident, suddenly the statements are true no matter what value guess takes: guess >= 1 || guess < 100 Just because (by virtue of guess actually being a number) it must be either greater than 1 (including 100, 101, 102, ...) or less than 100 (including 0, -1, -2, ...).","title":"Boolean Operators and Rules"},{"location":"java-from-python.html#addition-subtraction-shortcuts","text":"Something else you might have seen me do in Java is use a shortcut for addition or subtraction that isn't legal in Python. In Python we can do either of the following to look up the value of x , add 1 and store it back in x : # full intention: x = x + 1 # shortcut: x += 1 It turns out, in Java (and C and a few others...), we can do one more shortcut that means the same thing: // full intention: x = x + 1; // shortcut: x += 1; // even shorter: x++; // postfix ++x; // prefix There are shortcuts for subtraction as well: // full intention: x = x - 1; // shortcut: x -= 1; // even shorter: x--; // postfix --x; // prefix","title":"Addition / Subtraction shortcuts"},{"location":"java-from-python.html#prefix-vs-postfix-aside","text":"There are some subtle differences between prefix and postfix, but you need not worry about them in the official work of this class. We can write a program to investigate... A Java program to distinguish between pre-and-post operations: // Start at any value: int x = 7; // Postfix uses the value before changing it: System.out.println(x++); // prints: 7 System.out.println(x); // prints: 8 System.out.println(x--); // prints: 8 System.out.println(x); // prints: 7 // Prefix uses the value after changing it: System.out.println(++x); // prints: 8 System.out.println(x); // prints: 8 System.out.println(--x); // prints: 7 System.out.println(x); // prints: 7 I consider these operators to be useful tricks: not to be preferred over comments and clear code. I use ``x++`` in for loops because it's shorter (``++x`` would work as well, too).","title":"Prefix vs. Postfix Aside"},{"location":"java-from-python.html#exercises","text":"Write an absolute value method. Print lyrics to the \"Happy Birthday\" song.","title":"Exercises"},{"location":"list-methods.html","text":"Using Java's Lists This section will go over a few core methods of a list. Our goal is not to deeply study Java's implementations of things, but the concept of a List. That general concept is applicable outside of programming Java or any particular programming language. We say that a list is an Abstract Data Type -- it's something that's existed before computers and Java and will exist as a tool for problem solving regardless of what programming language or paradigm you will study in the future. The official documentation for Java's List is available online . If you don't have the link for a particular class, you can search for javadoc list online or access such pages from within your editor. If you code in Java, you will grow to rely on these documents for precise technical information. Java's List provides a lot of functionality; not only is there an add method that takes a single item, but an addAll method that takes another List . We can already write a simplified version of Java's addAll method, for any list type. // for a List<Anything> or List<T>: public void addAll(List<Anything> items) { for (Anything item : items) { this.add(item); } } So beyond Java's definition of what makes a class a List<T> which involves numerous other methods, there are a few operations that really define a what an abstract List can do, and you'll find them in any language with lists. What's an Anything or a T? When we refer to the List abstract data type, particularly in java, we sometimes refer to it as a List<T> . This means that it might be a List<Fish> a List<String> or any other particular class. Core Methods to Know Adding, viewing, and removing items are core to what a list is, but the most important thing a list does is maintain a sequence of items in the order you put them in. int size() To ask how many items are in a list, we can call the size method. List<String> abc = new ArrayList<>(); System.out.println(abc.size()); // prints: 0 abc.add(\"A\"); System.out.println(abc.size()); // prints: 1 abc.add(\"B\"); System.out.println(abc.size()); // prints: 2 abc.add(\"C\"); System.out.println(abc.size()); // prints: 3 We have already seen that size is useful in loops. boolean add(T item) A list isn't much use to us unless we can add things to it. Notice how we can't really use add without causing size to change. These two methods will always be related! List<String> abc = new ArrayList<>(); System.out.println(abc); // prints: [] abc.add(\"A\"); System.out.println(abc); // prints: [A] abc.add(\"B\"); System.out.println(abc); // prints: [A,B] abc.add(\"C\"); System.out.println(abc); // prints: [A,B,C] This method is configured to return a boolean -- that is, when you call add in Java a data structure has the opportunity to tell you it wasn't possible, and return false . This is meaningful when we get to discussing Set datastructures. T get(int index) Java, like Python and many other languages, indexes lists starting at zero and going up to the length of that list (not inclusively). List<String> abc = new ArrayList<>(); abc.add(\"A\"); abc.add(\"B\"); abc.add(\"C\"); System.out.println(abc.get(0)); // prints: A System.out.println(abc.get(1)); // prints: B System.out.println(abc.get(2)); // prints: C System.out.println(abc.get(3)); // crashes! System.out.println(abc.get(-1)); // crashes! When you go off the end of a List or an array in Java, an error will be thrown. You will see something like the following: java.lang.IndexOutOfBoundsException thrown: Index 3 out-of-bounds for length 3 at Preconditions.outOfBounds (Preconditions.java:64) at Preconditions.outOfBoundsCheckIndex (Preconditions.java:70) at Preconditions.checkIndex (Preconditions.java:248) at Objects.checkIndex (Objects.java:372) at ArrayList.get (ArrayList.java:440) at JavaListExperiments.main (JavaListExperiments.java:25) Note that it tells you that ArrayList.get was the problem in a class called JavaListExperiments and that index 3 was out-of-bounds for length 3. When you get an error like this, look for class names you recognize (we won't be discussing Objects or Preconditions in this book), so ArrayList and JavaListExperiments are most relevant to our code, and then also read the message that it gives you. Thanks to this error, we know exactly what line caused our problem (it was line 25 for me!). boolean add(int index, T item) There is another method named add on Java's list class, which supports adding an item to a particular position. // Set up our ABC list. List<String> abc = new ArrayList<>(); abc.add(\"A\"); abc.add(\"B\"); abc.add(\"C\"); System.out.println(abc); // prints: [A,B,C] // Now start inserting in the middle. abc.add(1, \"Z\"); System.out.println(abc); // prints: [A,Z,B,C] abc.add(0, \"Y\"); System.out.println(abc); // prints: [Y,A,Z,B,C] abc.add(abc.size()-1, \"X\"); System.out.println(abc); // prints: [Y,A,Z,B,X,C] Once again, this version of add also returns a boolean , but it will always return true . T remove(int index) Removing an item by its index is made possible by the remove method. It takes an int referring to the index to delete, and returns the value that was there, while modifying the list. // Set up our ABC list. List<String> abc = new ArrayList<>(); abc.add(\"A\"); abc.add(\"B\"); abc.add(\"C\"); System.out.println(abc); // prints: [A,B,C] // Remove B. System.out.println(abc.remove(1)); // prints: B // Remove C. System.out.println(abc.remove(1)); // prints: C // Remove A. System.out.println(abc.remove(0)); // prints: A Why does calling remove(1) return different String s each time we call it? Copying a list The two list classes, ArrayList and LinkedList -- as well as most other data structures Java gives you access to, can make a copy of another list using a special constructor. List<String> abc = new ArrayList<>(); abc.add(\"A\"); abc.add(\"B\"); abc.add(\"C\"); // Copy abc. List<String> copy = new ArrayList<>(abc); // Delete all elements from ABC. abc.clear(); System.out.println(abc); // prints: [] System.out.println(copy); // prints: [A, B, C] Some Additional Helpful Methods The following methods are available on Java's List and you'll want to use them from time to time. However, they can all be built out of the methods we already have. boolean contains(Object item) We can quickly check if a value is in a List using the contains method. List<String> ingredients = new ArrayList<>(); ingredients.add(\"Milk\"); ingredients.add(\"Eggs\"); ingredients.add(\"Flour\"); if (ingredients.contains(\"Flour\")) { System.out.println(\"We have flour!\"); } if (!ingredients.contains(\"Cheese\")) { System.out.println(\"We need cheese!\"); } We can imagine that this method is implemented as follows, given a list lookThrough and the item we're looking for findMe . public static boolean listContains(List<T> lookThrough, T findMe) { for (T actual : lookThrough) { if (findMe.equals(actual)) { return true; } } return false; } Notice that we get to return true immediately, as soon as we find a match, but in the worst case, we check every item in the list, and then return false because we don't find it. This method will work because a return statement immediately exits the method. Note as well that we use the .equals operation to compare our two items. Remember that in Java that == only works on primitives: boolean , int , etc. and asks whether two objects are the exact same object for any class type. Why does this method take an Object but all the others take a T ? This method is ancient! The earliest versions of Java did not have the ability to write List<T> but you could use List which functions as a List<Object> . Original methods, like this contains therefore asked for Object -type variables. They could not change it to T when they invented it (later) because it would break all the Java code already written to use it, and so it remains. Beware of type mismatches on contains because of this history: List<String> ingredients = new ArrayList<>(); ingredients.add(\"Milk\"); ingredients.add(\"Eggs\"); ingredients.add(\"Flour\"); if (ingredients.contains(7)) { System.out.println(\"There will never be numbers in ingredients!\"); } We would expect Java to warn us about asking for 7 in the ingredients list, because 7 is not a String and ingredients is a List<String> : therefore it will always return false , but it can't because the contains method is defined to take an Object and will therefore accept anything! int indexOf(T item) This method helps us find an item in our list. If it is in the list at all, we return the first position of that item. If we cannot find it, we get back -1 . List<String> ingredients = new ArrayList<>(); ingredients.add(\"Milk\"); ingredients.add(\"Eggs\"); ingredients.add(\"Flour\"); ingredients.add(\"Eggs\"); System.out.println(ingredients.indexOf(\"Milk\")); // prints: 0 System.out.println(ingredients.indexOf(\"Eggs\")); // prints: 1 System.out.println(ingredients.indexOf(\"Bacon\")); // prints: -1 Again, we can write a version of this method given the ones we already know. It looks a lot like listContains ! public static boolean listFindIndex(List<T> lookThrough, T findMe) { for (int index=0; index<lookThrough.size(); index++) { if (findMe.equals(actual)) { return index; } } return -1; } Note that we had to change which style of for-loop we used in order to write this method. boolean remove(T item) We can also remove items by value; that is: we search through the list, and if we find the item, we remove it. This time, we implement it using indexOf and the other remove . boolean listRemoveByItem(List<T> lookThrough, T removeMe) { int index = lookThrough.indexOf(removeMe); if (index >= 0) { return lookThrough.remove(index); } return false; } Write and test this method without using indexOf . Non-Member Methods Not all list functionality that comes with Java lives on the List class. A lot of the static methods on java.util.Collections may be very useful. Here are some of the most useful. Collections.sort(List modify) Although we will discuss sorting later in more detail, sorting is an incredibly useful tool for solving problems. Most of the time we want to use Java's sorting algorithm to do that work for us, unless we have a special case where we need to write it ourselves. // Set up our ABC list, but backwards. List<String> cba = new ArrayList<>(); cba.add(\"C\"); cba.add(\"B\"); cba.add(\"A\"); System.out.println(cba); // prints: [C,B,A] // Sort it! Collections.sort(cba); System.out.println(cba); // prints: [A,B,C] This method, like all others, modifies a list in place, so we might need to make a copy of a list first, if we want it both sorted and not-sorted. Collections.reverse(List modify) We can also reverse a list, no matter what it is. List<String> racer = new ArrayList<>(); racer.add(\"R\"); racer.add(\"A\"); racer.add(\"C\"); racer.add(\"E\"); racer.add(\"R\"); System.out.println(racer); // prints: [R,A,C,E,R] Collections.reverse(racer); System.out.println(racer); // prints: [R,E,C,A,R] Why would the word \"Racecar\" be a bad choice for testing the above code? Collections.shuffle(List modify) You can also shuffle a list in Java. Try the following example a few times to see what it prints. The output should change each time you run it. // Set up our ABC list, but backwards. List<String> abc = new ArrayList<>(); abc.add(\"A\"); abc.add(\"B\"); abc.add(\"C\"); abc.add(\"D\"); abc.add(\"E\"); abc.add(\"F\"); System.out.println(abc); // prints: [A,B,C,D,E,F] Collections.shuffle(abc); System.out.println(abc); // Try this a few times! If you're interested in how shuffling works, check out the Fisher-Yates Shuffle . One approach to this problem is to assign random numbers to every entry in your list, and sort it. The \"Fisher-Yates Shuffle\" is more efficient. Some Differences from Python Python's list is a built-in data type that provides some of the same abstract operations, under different names. If you previously studied python, it may be interesting or helpful for you to review some of the differences. In python, size() was available as a special operation: len , not a method. abc = [\"A\",\"B\",\"C\"] print(len(abc)) # prints: 3 In python, add is called append . Adding at a particular index was called insert . abc = [] abc.append(\"A\") abc.append(\"B\") abc.append(\"C\") print(abc) # prints: [A,B,C] There is no get method, just square brackets. Python also supported negative indices, but in Java you must use size to get the last element. print(abc[0]) # prints: A print(abc[1]) # prints: B print(abc[-1]) # prints: C # negative indexing is a short-hand for using the size print(abc[len(abc)-1]) # prints: C // Equivalent to Python's abc[-1]: System.out.println(abc.get(abc.size()-1)); Summary of Methods Java Method Java Usage Closest Python Java Description int size() xs.size() len(xs) returns the number of items boolean add(T) xs.add(x) xs.append(x) adds an item to the back of the list T get(int) xs.get(i) xs[i] get an item at the index boolean add(int, T) xs.add(i, x) xs.insert(i, x) inserts an item before the index boolean contains(T) xs.contains(x) x in xs returns true if the list has the item. int indexOf(T) xs.indexOf(x) xs.index(x) returns the position of the item, or -1 if not found. boolean remove(T) xs.remove(x) xs.remove(x) returns true if the item was found and deleted. T remove(int) xs.remove(i) del xs[index] returns the item at the given position and removes it. Challenges Pick a Random Letter Using a list of all the letters in the dictionary, e.g., List<Character> letters = new ArrayList<>(); for (char c = 'A'; c <= 'Z'; c++) { letters.add(c); } Write code to choose a letter at random. Remove the Last Item from a List Using the following starter-code, finish the definition of removeBack so it finds the last item from a list and returns it. public static String removeBack(List<String> input) { // TODO: return the last item (and remove it!). } // ... public static void main(String[] args) { List<String> abc = new ArrayList<>(); abc.add(\"A\"); abc.add(\"B\"); abc.add(\"C\"); System.out.println(removeBack()); // should print: C System.out.println(abc); // should print: [A, B] } HINT: what index is the last?","title":"\ud83d\udcd6 Using Lists"},{"location":"list-methods.html#using-javas-lists","text":"This section will go over a few core methods of a list. Our goal is not to deeply study Java's implementations of things, but the concept of a List. That general concept is applicable outside of programming Java or any particular programming language. We say that a list is an Abstract Data Type -- it's something that's existed before computers and Java and will exist as a tool for problem solving regardless of what programming language or paradigm you will study in the future. The official documentation for Java's List is available online . If you don't have the link for a particular class, you can search for javadoc list online or access such pages from within your editor. If you code in Java, you will grow to rely on these documents for precise technical information. Java's List provides a lot of functionality; not only is there an add method that takes a single item, but an addAll method that takes another List . We can already write a simplified version of Java's addAll method, for any list type. // for a List<Anything> or List<T>: public void addAll(List<Anything> items) { for (Anything item : items) { this.add(item); } } So beyond Java's definition of what makes a class a List<T> which involves numerous other methods, there are a few operations that really define a what an abstract List can do, and you'll find them in any language with lists.","title":"Using Java's Lists"},{"location":"list-methods.html#whats-an-anything-or-a-t","text":"When we refer to the List abstract data type, particularly in java, we sometimes refer to it as a List<T> . This means that it might be a List<Fish> a List<String> or any other particular class.","title":"What's an Anything or a T?"},{"location":"list-methods.html#core-methods-to-know","text":"Adding, viewing, and removing items are core to what a list is, but the most important thing a list does is maintain a sequence of items in the order you put them in.","title":"Core Methods to Know"},{"location":"list-methods.html#int-size","text":"To ask how many items are in a list, we can call the size method. List<String> abc = new ArrayList<>(); System.out.println(abc.size()); // prints: 0 abc.add(\"A\"); System.out.println(abc.size()); // prints: 1 abc.add(\"B\"); System.out.println(abc.size()); // prints: 2 abc.add(\"C\"); System.out.println(abc.size()); // prints: 3 We have already seen that size is useful in loops.","title":"int size()"},{"location":"list-methods.html#boolean-addt-item","text":"A list isn't much use to us unless we can add things to it. Notice how we can't really use add without causing size to change. These two methods will always be related! List<String> abc = new ArrayList<>(); System.out.println(abc); // prints: [] abc.add(\"A\"); System.out.println(abc); // prints: [A] abc.add(\"B\"); System.out.println(abc); // prints: [A,B] abc.add(\"C\"); System.out.println(abc); // prints: [A,B,C] This method is configured to return a boolean -- that is, when you call add in Java a data structure has the opportunity to tell you it wasn't possible, and return false . This is meaningful when we get to discussing Set datastructures.","title":"boolean add(T item)"},{"location":"list-methods.html#t-getint-index","text":"Java, like Python and many other languages, indexes lists starting at zero and going up to the length of that list (not inclusively). List<String> abc = new ArrayList<>(); abc.add(\"A\"); abc.add(\"B\"); abc.add(\"C\"); System.out.println(abc.get(0)); // prints: A System.out.println(abc.get(1)); // prints: B System.out.println(abc.get(2)); // prints: C System.out.println(abc.get(3)); // crashes! System.out.println(abc.get(-1)); // crashes! When you go off the end of a List or an array in Java, an error will be thrown. You will see something like the following: java.lang.IndexOutOfBoundsException thrown: Index 3 out-of-bounds for length 3 at Preconditions.outOfBounds (Preconditions.java:64) at Preconditions.outOfBoundsCheckIndex (Preconditions.java:70) at Preconditions.checkIndex (Preconditions.java:248) at Objects.checkIndex (Objects.java:372) at ArrayList.get (ArrayList.java:440) at JavaListExperiments.main (JavaListExperiments.java:25) Note that it tells you that ArrayList.get was the problem in a class called JavaListExperiments and that index 3 was out-of-bounds for length 3. When you get an error like this, look for class names you recognize (we won't be discussing Objects or Preconditions in this book), so ArrayList and JavaListExperiments are most relevant to our code, and then also read the message that it gives you. Thanks to this error, we know exactly what line caused our problem (it was line 25 for me!).","title":"T get(int index)"},{"location":"list-methods.html#boolean-addint-index-t-item","text":"There is another method named add on Java's list class, which supports adding an item to a particular position. // Set up our ABC list. List<String> abc = new ArrayList<>(); abc.add(\"A\"); abc.add(\"B\"); abc.add(\"C\"); System.out.println(abc); // prints: [A,B,C] // Now start inserting in the middle. abc.add(1, \"Z\"); System.out.println(abc); // prints: [A,Z,B,C] abc.add(0, \"Y\"); System.out.println(abc); // prints: [Y,A,Z,B,C] abc.add(abc.size()-1, \"X\"); System.out.println(abc); // prints: [Y,A,Z,B,X,C] Once again, this version of add also returns a boolean , but it will always return true .","title":"boolean add(int index, T item)"},{"location":"list-methods.html#t-removeint-index","text":"Removing an item by its index is made possible by the remove method. It takes an int referring to the index to delete, and returns the value that was there, while modifying the list. // Set up our ABC list. List<String> abc = new ArrayList<>(); abc.add(\"A\"); abc.add(\"B\"); abc.add(\"C\"); System.out.println(abc); // prints: [A,B,C] // Remove B. System.out.println(abc.remove(1)); // prints: B // Remove C. System.out.println(abc.remove(1)); // prints: C // Remove A. System.out.println(abc.remove(0)); // prints: A Why does calling remove(1) return different String s each time we call it?","title":"T remove(int index)"},{"location":"list-methods.html#copying-a-list","text":"The two list classes, ArrayList and LinkedList -- as well as most other data structures Java gives you access to, can make a copy of another list using a special constructor. List<String> abc = new ArrayList<>(); abc.add(\"A\"); abc.add(\"B\"); abc.add(\"C\"); // Copy abc. List<String> copy = new ArrayList<>(abc); // Delete all elements from ABC. abc.clear(); System.out.println(abc); // prints: [] System.out.println(copy); // prints: [A, B, C]","title":"Copying a list"},{"location":"list-methods.html#some-additional-helpful-methods","text":"The following methods are available on Java's List and you'll want to use them from time to time. However, they can all be built out of the methods we already have.","title":"Some Additional Helpful Methods"},{"location":"list-methods.html#boolean-containsobject-item","text":"We can quickly check if a value is in a List using the contains method. List<String> ingredients = new ArrayList<>(); ingredients.add(\"Milk\"); ingredients.add(\"Eggs\"); ingredients.add(\"Flour\"); if (ingredients.contains(\"Flour\")) { System.out.println(\"We have flour!\"); } if (!ingredients.contains(\"Cheese\")) { System.out.println(\"We need cheese!\"); } We can imagine that this method is implemented as follows, given a list lookThrough and the item we're looking for findMe . public static boolean listContains(List<T> lookThrough, T findMe) { for (T actual : lookThrough) { if (findMe.equals(actual)) { return true; } } return false; } Notice that we get to return true immediately, as soon as we find a match, but in the worst case, we check every item in the list, and then return false because we don't find it. This method will work because a return statement immediately exits the method. Note as well that we use the .equals operation to compare our two items. Remember that in Java that == only works on primitives: boolean , int , etc. and asks whether two objects are the exact same object for any class type. Why does this method take an Object but all the others take a T ? This method is ancient! The earliest versions of Java did not have the ability to write List<T> but you could use List which functions as a List<Object> . Original methods, like this contains therefore asked for Object -type variables. They could not change it to T when they invented it (later) because it would break all the Java code already written to use it, and so it remains. Beware of type mismatches on contains because of this history: List<String> ingredients = new ArrayList<>(); ingredients.add(\"Milk\"); ingredients.add(\"Eggs\"); ingredients.add(\"Flour\"); if (ingredients.contains(7)) { System.out.println(\"There will never be numbers in ingredients!\"); } We would expect Java to warn us about asking for 7 in the ingredients list, because 7 is not a String and ingredients is a List<String> : therefore it will always return false , but it can't because the contains method is defined to take an Object and will therefore accept anything!","title":"boolean contains(Object item)"},{"location":"list-methods.html#int-indexoft-item","text":"This method helps us find an item in our list. If it is in the list at all, we return the first position of that item. If we cannot find it, we get back -1 . List<String> ingredients = new ArrayList<>(); ingredients.add(\"Milk\"); ingredients.add(\"Eggs\"); ingredients.add(\"Flour\"); ingredients.add(\"Eggs\"); System.out.println(ingredients.indexOf(\"Milk\")); // prints: 0 System.out.println(ingredients.indexOf(\"Eggs\")); // prints: 1 System.out.println(ingredients.indexOf(\"Bacon\")); // prints: -1 Again, we can write a version of this method given the ones we already know. It looks a lot like listContains ! public static boolean listFindIndex(List<T> lookThrough, T findMe) { for (int index=0; index<lookThrough.size(); index++) { if (findMe.equals(actual)) { return index; } } return -1; } Note that we had to change which style of for-loop we used in order to write this method.","title":"int indexOf(T item)"},{"location":"list-methods.html#boolean-removet-item","text":"We can also remove items by value; that is: we search through the list, and if we find the item, we remove it. This time, we implement it using indexOf and the other remove . boolean listRemoveByItem(List<T> lookThrough, T removeMe) { int index = lookThrough.indexOf(removeMe); if (index >= 0) { return lookThrough.remove(index); } return false; } Write and test this method without using indexOf .","title":"boolean remove(T item)"},{"location":"list-methods.html#non-member-methods","text":"Not all list functionality that comes with Java lives on the List class. A lot of the static methods on java.util.Collections may be very useful. Here are some of the most useful.","title":"Non-Member Methods"},{"location":"list-methods.html#collectionssortlist-modify","text":"Although we will discuss sorting later in more detail, sorting is an incredibly useful tool for solving problems. Most of the time we want to use Java's sorting algorithm to do that work for us, unless we have a special case where we need to write it ourselves. // Set up our ABC list, but backwards. List<String> cba = new ArrayList<>(); cba.add(\"C\"); cba.add(\"B\"); cba.add(\"A\"); System.out.println(cba); // prints: [C,B,A] // Sort it! Collections.sort(cba); System.out.println(cba); // prints: [A,B,C] This method, like all others, modifies a list in place, so we might need to make a copy of a list first, if we want it both sorted and not-sorted.","title":"Collections.sort(List modify)"},{"location":"list-methods.html#collectionsreverselist-modify","text":"We can also reverse a list, no matter what it is. List<String> racer = new ArrayList<>(); racer.add(\"R\"); racer.add(\"A\"); racer.add(\"C\"); racer.add(\"E\"); racer.add(\"R\"); System.out.println(racer); // prints: [R,A,C,E,R] Collections.reverse(racer); System.out.println(racer); // prints: [R,E,C,A,R] Why would the word \"Racecar\" be a bad choice for testing the above code?","title":"Collections.reverse(List modify)"},{"location":"list-methods.html#collectionsshufflelist-modify","text":"You can also shuffle a list in Java. Try the following example a few times to see what it prints. The output should change each time you run it. // Set up our ABC list, but backwards. List<String> abc = new ArrayList<>(); abc.add(\"A\"); abc.add(\"B\"); abc.add(\"C\"); abc.add(\"D\"); abc.add(\"E\"); abc.add(\"F\"); System.out.println(abc); // prints: [A,B,C,D,E,F] Collections.shuffle(abc); System.out.println(abc); // Try this a few times! If you're interested in how shuffling works, check out the Fisher-Yates Shuffle . One approach to this problem is to assign random numbers to every entry in your list, and sort it. The \"Fisher-Yates Shuffle\" is more efficient.","title":"Collections.shuffle(List modify)"},{"location":"list-methods.html#some-differences-from-python","text":"Python's list is a built-in data type that provides some of the same abstract operations, under different names. If you previously studied python, it may be interesting or helpful for you to review some of the differences. In python, size() was available as a special operation: len , not a method. abc = [\"A\",\"B\",\"C\"] print(len(abc)) # prints: 3 In python, add is called append . Adding at a particular index was called insert . abc = [] abc.append(\"A\") abc.append(\"B\") abc.append(\"C\") print(abc) # prints: [A,B,C] There is no get method, just square brackets. Python also supported negative indices, but in Java you must use size to get the last element. print(abc[0]) # prints: A print(abc[1]) # prints: B print(abc[-1]) # prints: C # negative indexing is a short-hand for using the size print(abc[len(abc)-1]) # prints: C // Equivalent to Python's abc[-1]: System.out.println(abc.get(abc.size()-1));","title":"Some Differences from Python"},{"location":"list-methods.html#summary-of-methods","text":"Java Method Java Usage Closest Python Java Description int size() xs.size() len(xs) returns the number of items boolean add(T) xs.add(x) xs.append(x) adds an item to the back of the list T get(int) xs.get(i) xs[i] get an item at the index boolean add(int, T) xs.add(i, x) xs.insert(i, x) inserts an item before the index boolean contains(T) xs.contains(x) x in xs returns true if the list has the item. int indexOf(T) xs.indexOf(x) xs.index(x) returns the position of the item, or -1 if not found. boolean remove(T) xs.remove(x) xs.remove(x) returns true if the item was found and deleted. T remove(int) xs.remove(i) del xs[index] returns the item at the given position and removes it.","title":"Summary of Methods"},{"location":"list-methods.html#challenges","text":"","title":"Challenges"},{"location":"objects-101.html","text":"Objects & Classes Object-Oriented Programming (OOP) is a way of organizing data (aka State) and code (aka methods, functions, Behavior) into classes and objects. Classes are like stamps or templates, in that you can create many instances of the class, called objects. A Tale of two Wallets // I did not have a lot of money to spend in College. OneCard me = new OneCard(\"Myself\", 3.00); // But I had friends with lots of money. Like, $50. OneCard myRichFriend = new OneCard(\"Friend\", 50.00); // To make it worse, they could add money to their card all the time, like $20! myRichFriend.deposit(20.00); // I can't afford $60 worth of anything. System.out.println(me.canAfford(60.00)); // prints: false // But my friend could. System.out.println(myRichFriend.canAfford(60.00)); // prints: true // That is, until they spent $13.87 on a fancy coffee of some kind. myRichFriend.spend(13.87); // Now, they can't afford a $60 thing. System.out.println(myRichFriend.canAfford(60.00)); // prints: false Running this code will give the following output: false true false In this previous example -- there are two objects of type OneCard which models a person's wallet. We could have written a similar sassy story using variables of type double but numbers don't have nice methods like canAfford , deposit and spend . Also, in a bigger example, we'd want to associate names with accounts and maybe keep a list of transactions. To build this class, I would first create a new file, named OneCard.java . Then I would add fields to this class, a double balance and maybe a String owner . Then we need a constructor -- something that will create a new object when we call new OneCard(...) . Then we would design the methods: canAfford , deposit and spend . Creating the OneCard class: fields and a constructor public class OneCard { /** Who owns this card? */ String owner; /** How much money is stored here? */ double balance; public OneCard(String person, double money) { this.owner = person; this.balance = money; } // ... methods later go here ... } Fields live on the class itself, and by convention, we put them at the top, although we could put them anywhere. This code is the constructor. Note that it's not quite a normal method definition -- we have public but the name and the return-type have been merged to be OneCard the name of the class. This marks the method as being special: a constructor. public OneCard(String person, double money) { this.owner = person; this.balance = money; } This method has two parameters: String person and double money . In the longer code example, person is first \"Myself\" and then \"Friend\" , and money changes similarly. We could create yet another instance of a OneCard by running the following code: OneCard empty = new OneCard(\"unknown\", 0.00); Then, we have effectively created empty.balance = 0.00; and empty.owner = \"unknown\"; by calling the constructor via the new keyword. Methods of OneCard deposit and canAfford The following is a possible definition of both deposit and canAfford on our OneCard class. Notice that nothing on this class uses the static keyword -- this is important. We want access to owner and balance in these methods; but we need to go through the this keyword, which is a special variable that represents the current instance of the class. When we call something like me.canAfford(...) the variable me becomes this for the body of the method canAfford in this case, that gets called. public class OneCard { /** Who owns this card? */ String owner; /** How much money is stored here? */ double balance; public OneCard(String person, double money) { this.owner = person; this.balance = money; } public void deposit(double amount) { this.balance += amount; } public boolean canAfford(double amount) { return this.balance > amount; } // we'll put spend here... } Here we get a clue to the meaning of void -- something that's part of the main method we've learned to type. void means nothing -- so when we put it in the return-value position for a method, it means that our method returns nothing. Adding money to a bank account or a OneCard should always succeed, so I don't know what we would return here (maybe the new balance?) but it's appropriate to return nothing. spend (to demonstrate exceptions!) Spend is an interesting operation -- because it should be able to fail if you don't have enough money. This will be true when we get to the data structures portion of the class (imagine asking to delete from an empty list, or asking for item number 5 of a 3 item list.). public void spend(double amount) { if (!this.canAfford(amount)) { throw new RuntimeException(this.owner + \" can't afford \"+amount); } this.balance -= amount; } There are many types of exceptions (or errors) in Java. We saw one in the GuessingGame. When we want to create our own error, and crash the program, we will use RuntimeException . Language: Response: English \"You can\u2019t do that!\" Python raise ValueError(message) Java throw new RuntimeException(message); It may be a better design to make a spend that returns a true/false value, i.e., public boolean spend(double amount) { if (!this.canAfford(amount)) { return false; } this.balance -= amount; return true; } Because then you can choose how to handle not being able to spend the money in the code that is interacting with teh OneCard class. So then, what's a static method? All of the methods presented above are instance methods , which means they depend on a particular instance of a class. Static methods, like the public static void main(String[] args) { } we use to run code do not need or have access to a this special variable; and that can be a good thing! For the OneCard example, imagine that we wanted a set of vendors that accepted the OneCard as money. This would not be different for each OneCard , but we may want that set to be associated with the class anyway: public class OneCard { // everything we've seen. /** Supported set of vendors -- can't have any duplicates, so we use a set rather than a list. */ public static Set<String> supportedStores = new HashSet<String>(); } We will discuss sets further in the future -- think of them as lists that keep items unique and remove duplicates for you! Vocabulary In this section, we try to define a lot of common terminology for classes. An Object is an instance of a Class. Classes are the template, and objects are generated from the template. State and Behavior There are many programming languages that use Object-Oriented programming concepts, and as a result, there are many names for some of these things! Behavior We will refer to methods on a class as \"methods\" but there are static methods on a class, and so sometimes we will refer to them as \"instance methods\" to tell them apart from static methods. Method Instance Method Action Messages / Signals State There are many names for the variables associated with a class. Instance Variables Member Variables Members Properties Attributes Fields Constructors Constructors run code on the new keyword. The parameters they ask for are used to set up the class (but they need not be instance variables.) Parameters vs. Variables In a hypothetical Dog class, we might want to store the age of a dog in so-called \"dog-years\" rather than \"human-years.\" public class Dog { private int dogYears; public String name; public Dog(String name, int yearsOld) { this.name = name; this.dogYears = yearsOld * 7; } public int getDogYears() { return this.dogYears; } public int getHumanYears() { return this.dogYears / 7; } } By then writing methods for getting to our dogYears instance variable, users of this class don't need to know whether human years or dog years are stored, merely that they have access to both! Class keywords There are a lot of other keywords that go with classes. I'll try to define them here. public vs. private For now, our definition of public is that it allows you to see variables, methods, and classes marked with it from other .java source code files. Therefore, when in doubt, we can lean toward making things public . For now, our definition of private is that it allows you to hide variables, methods, and classes marked with it from other .java source code files: in our earlier example about Parameters and Variables where we discussed the private int dogYears field, it made sense to hide it from the user and make them call the public methods to get either getHumanYears() or getDogYears() . Note that there are two other levels of visibility in Java: package and protected . package -level things can be seen from files and classes the same folder as the current class (this is what happens when you just write int dogYears on a field -- there's no package keyword despite it being a level). And protected makes things visible to classes that inherit directly from this class -- we will discuss inheritance later in the course. static vs. instance I have the opinion that all dogs are cute. Having a variable to represent a specific dog, e.g., buddy is not necessary for knowing whether a dog is cute. Signature Has this reference? How do I call it? public static boolean isCute() No this involved. if (Dog.isCute()) { \u2026 } public boolean isCute() this=buddy or whichever object you call it on. if (buddy.isCute()) { \u2026 } Methods that are in a class (because Java requires everything to be in a class) but don't really need to be are called static methods . You can also have static variables . Notably, you don't need to create an object in order to call them. This is useful to Java as well as to us -- recall our main method: public static void main(String[] args) { // public // lets us start the program from outside the file it is defined. // static // lets us run the code in main without creating the object that owns it. // void // means that it doesn't return anything. // String[] args // is an array of strings from the user to start this program; // although it will always be blank in this class. }","title":"\ud83d\udcd6 Classes & Objects"},{"location":"objects-101.html#objects-classes","text":"Object-Oriented Programming (OOP) is a way of organizing data (aka State) and code (aka methods, functions, Behavior) into classes and objects. Classes are like stamps or templates, in that you can create many instances of the class, called objects.","title":"Objects &amp; Classes"},{"location":"objects-101.html#a-tale-of-two-wallets","text":"// I did not have a lot of money to spend in College. OneCard me = new OneCard(\"Myself\", 3.00); // But I had friends with lots of money. Like, $50. OneCard myRichFriend = new OneCard(\"Friend\", 50.00); // To make it worse, they could add money to their card all the time, like $20! myRichFriend.deposit(20.00); // I can't afford $60 worth of anything. System.out.println(me.canAfford(60.00)); // prints: false // But my friend could. System.out.println(myRichFriend.canAfford(60.00)); // prints: true // That is, until they spent $13.87 on a fancy coffee of some kind. myRichFriend.spend(13.87); // Now, they can't afford a $60 thing. System.out.println(myRichFriend.canAfford(60.00)); // prints: false Running this code will give the following output: false true false In this previous example -- there are two objects of type OneCard which models a person's wallet. We could have written a similar sassy story using variables of type double but numbers don't have nice methods like canAfford , deposit and spend . Also, in a bigger example, we'd want to associate names with accounts and maybe keep a list of transactions. To build this class, I would first create a new file, named OneCard.java . Then I would add fields to this class, a double balance and maybe a String owner . Then we need a constructor -- something that will create a new object when we call new OneCard(...) . Then we would design the methods: canAfford , deposit and spend .","title":"A Tale of two Wallets"},{"location":"objects-101.html#creating-the-onecard-class-fields-and-a-constructor","text":"public class OneCard { /** Who owns this card? */ String owner; /** How much money is stored here? */ double balance; public OneCard(String person, double money) { this.owner = person; this.balance = money; } // ... methods later go here ... } Fields live on the class itself, and by convention, we put them at the top, although we could put them anywhere. This code is the constructor. Note that it's not quite a normal method definition -- we have public but the name and the return-type have been merged to be OneCard the name of the class. This marks the method as being special: a constructor. public OneCard(String person, double money) { this.owner = person; this.balance = money; } This method has two parameters: String person and double money . In the longer code example, person is first \"Myself\" and then \"Friend\" , and money changes similarly. We could create yet another instance of a OneCard by running the following code: OneCard empty = new OneCard(\"unknown\", 0.00); Then, we have effectively created empty.balance = 0.00; and empty.owner = \"unknown\"; by calling the constructor via the new keyword.","title":"Creating the OneCard class: fields and a constructor"},{"location":"objects-101.html#methods-of-onecard","text":"","title":"Methods of OneCard"},{"location":"objects-101.html#deposit-and-canafford","text":"The following is a possible definition of both deposit and canAfford on our OneCard class. Notice that nothing on this class uses the static keyword -- this is important. We want access to owner and balance in these methods; but we need to go through the this keyword, which is a special variable that represents the current instance of the class. When we call something like me.canAfford(...) the variable me becomes this for the body of the method canAfford in this case, that gets called. public class OneCard { /** Who owns this card? */ String owner; /** How much money is stored here? */ double balance; public OneCard(String person, double money) { this.owner = person; this.balance = money; } public void deposit(double amount) { this.balance += amount; } public boolean canAfford(double amount) { return this.balance > amount; } // we'll put spend here... } Here we get a clue to the meaning of void -- something that's part of the main method we've learned to type. void means nothing -- so when we put it in the return-value position for a method, it means that our method returns nothing. Adding money to a bank account or a OneCard should always succeed, so I don't know what we would return here (maybe the new balance?) but it's appropriate to return nothing.","title":"deposit and canAfford"},{"location":"objects-101.html#spend-to-demonstrate-exceptions","text":"Spend is an interesting operation -- because it should be able to fail if you don't have enough money. This will be true when we get to the data structures portion of the class (imagine asking to delete from an empty list, or asking for item number 5 of a 3 item list.). public void spend(double amount) { if (!this.canAfford(amount)) { throw new RuntimeException(this.owner + \" can't afford \"+amount); } this.balance -= amount; } There are many types of exceptions (or errors) in Java. We saw one in the GuessingGame. When we want to create our own error, and crash the program, we will use RuntimeException . Language: Response: English \"You can\u2019t do that!\" Python raise ValueError(message) Java throw new RuntimeException(message); It may be a better design to make a spend that returns a true/false value, i.e., public boolean spend(double amount) { if (!this.canAfford(amount)) { return false; } this.balance -= amount; return true; } Because then you can choose how to handle not being able to spend the money in the code that is interacting with teh OneCard class.","title":"spend (to demonstrate exceptions!)"},{"location":"objects-101.html#so-then-whats-a-static-method","text":"All of the methods presented above are instance methods , which means they depend on a particular instance of a class. Static methods, like the public static void main(String[] args) { } we use to run code do not need or have access to a this special variable; and that can be a good thing! For the OneCard example, imagine that we wanted a set of vendors that accepted the OneCard as money. This would not be different for each OneCard , but we may want that set to be associated with the class anyway: public class OneCard { // everything we've seen. /** Supported set of vendors -- can't have any duplicates, so we use a set rather than a list. */ public static Set<String> supportedStores = new HashSet<String>(); } We will discuss sets further in the future -- think of them as lists that keep items unique and remove duplicates for you!","title":"So then, what's a static method?"},{"location":"objects-101.html#vocabulary","text":"In this section, we try to define a lot of common terminology for classes.","title":"Vocabulary"},{"location":"objects-101.html#an-object-is-an-instance-of-a-class","text":"Classes are the template, and objects are generated from the template.","title":"An Object is an instance of a Class."},{"location":"objects-101.html#state-and-behavior","text":"There are many programming languages that use Object-Oriented programming concepts, and as a result, there are many names for some of these things!","title":"State and Behavior"},{"location":"objects-101.html#behavior","text":"We will refer to methods on a class as \"methods\" but there are static methods on a class, and so sometimes we will refer to them as \"instance methods\" to tell them apart from static methods. Method Instance Method Action Messages / Signals","title":"Behavior"},{"location":"objects-101.html#state","text":"There are many names for the variables associated with a class. Instance Variables Member Variables Members Properties Attributes Fields","title":"State"},{"location":"objects-101.html#constructors","text":"Constructors run code on the new keyword. The parameters they ask for are used to set up the class (but they need not be instance variables.)","title":"Constructors"},{"location":"objects-101.html#parameters-vs-variables","text":"In a hypothetical Dog class, we might want to store the age of a dog in so-called \"dog-years\" rather than \"human-years.\" public class Dog { private int dogYears; public String name; public Dog(String name, int yearsOld) { this.name = name; this.dogYears = yearsOld * 7; } public int getDogYears() { return this.dogYears; } public int getHumanYears() { return this.dogYears / 7; } } By then writing methods for getting to our dogYears instance variable, users of this class don't need to know whether human years or dog years are stored, merely that they have access to both!","title":"Parameters vs. Variables"},{"location":"objects-101.html#class-keywords","text":"There are a lot of other keywords that go with classes. I'll try to define them here.","title":"Class keywords"},{"location":"objects-101.html#public-vs-private","text":"For now, our definition of public is that it allows you to see variables, methods, and classes marked with it from other .java source code files. Therefore, when in doubt, we can lean toward making things public . For now, our definition of private is that it allows you to hide variables, methods, and classes marked with it from other .java source code files: in our earlier example about Parameters and Variables where we discussed the private int dogYears field, it made sense to hide it from the user and make them call the public methods to get either getHumanYears() or getDogYears() . Note that there are two other levels of visibility in Java: package and protected . package -level things can be seen from files and classes the same folder as the current class (this is what happens when you just write int dogYears on a field -- there's no package keyword despite it being a level). And protected makes things visible to classes that inherit directly from this class -- we will discuss inheritance later in the course.","title":"public vs. private"},{"location":"objects-101.html#static-vs-instance","text":"I have the opinion that all dogs are cute. Having a variable to represent a specific dog, e.g., buddy is not necessary for knowing whether a dog is cute. Signature Has this reference? How do I call it? public static boolean isCute() No this involved. if (Dog.isCute()) { \u2026 } public boolean isCute() this=buddy or whichever object you call it on. if (buddy.isCute()) { \u2026 } Methods that are in a class (because Java requires everything to be in a class) but don't really need to be are called static methods . You can also have static variables . Notably, you don't need to create an object in order to call them. This is useful to Java as well as to us -- recall our main method: public static void main(String[] args) { // public // lets us start the program from outside the file it is defined. // static // lets us run the code in main without creating the object that owns it. // void // means that it doesn't return anything. // String[] args // is an array of strings from the user to start this program; // although it will always be blank in this class. }","title":"static vs. instance"},{"location":"stacks-and-queues.html","text":"Stacks & Queues It turns out that lists are very useful data structures. In fact, people use lists for all sorts of behaviors. Two behaviors are so common that we have given them their own names. We will discuss these behaviors again when we are implementing our own data structures but here we discuss these \"archetypal\" data structures. Queues (FIFO) Queues are type of list where you are always operating on opposite ends of a list. Imagine you're waiting in line for food at a dining hall or at a restaurant. You see a line of people, and so you add yourself to the back of the line. The dining hall serves people one at a time from the front of the line. You know that eventually you will reach the front. Queue behavior is sometimes referred to as \"First-Come First-Serve\" (FCFS) or \"First-In, First-Out\" (FIFO). Java has a Queue class, and LinkedList is a queue. Queue<String> diningHall = new LinkedList<>(); diningHall.add(\"A\"); diningHall.add(\"B\"); System.out.println(diningHall.remove()); // prints: A diningHall.add(\"C\"); diningHall.add(\"D\"); System.out.println(diningHall.remove()); // prints: B System.out.println(diningHall.remove()); // prints: C System.out.println(diningHall.remove()); // prints: D Note that we could have written this program with diningHall.remove(0) on a regular List<String> . Choosing Queue over List typically means that you know exactly how you are going to use this data structure and it would help readers of your code to know that, too. Stacks (LIFO) Stacks are a type of list where you are always operating on the same side. Imagine you take all your textbooks and pile them up on top of your desk. You realize that your computer science book is on the bottom, and your Spanish Language textbook is on top. You decide to do your Spanish homework first, so as not to knock over your stack of books. Stacks allow you to pile up work for later, and get back to it in a \"most-recent\" first manner. Stack behavior is sometimes referred to as \"Last-In, First-Out\" (LIFO) in symmetry to Queues which are FIFO. Java has a Stack class, but they don't recommend it. In fact they recommend the Deque interface, which is more powerful and we will discuss briefly in the next section. You can remove from the back of any list by doing: list.remove(list.size()-1) . List<String> books = new ArrayList<>(); books.add(\"CS\"); books.add(\"Philosphy\"); System.out.println(books.remove(books.size()-1)); // prints: Philosophy books.add(\"Logic\"); books.add(\"Spanish\"); System.out.println(books.remove(books.size()-1)); // prints: Spanish System.out.println(books.remove(books.size()-1)); // prints: Logic System.out.println(books.remove(books.size()-1)); // prints: CS If you really want a stack for your project, it may make sense to write a simple class to handle it: /** Design push/pop for more clear stack-code */ public class StackOfBooks { /** Using an arraylist to build a Stack. */ private List<String> books = new ArrayList<String>(); /** Add a book to the top of the stack */ public void push(String book) { this.books.add(book); } /** Remove a book from the top of the stack */ public String pop() { if (this.books.size() == 0) { throw new IllegalStateException(\"Out of books!\"); } return this.books.remove(this.books.size() - 1); } public static void main(String[] args) { StackOfBooks books = new StackOfBooks(); books.push(\"CS\"); books.push(\"Philosphy\"); System.out.println(books.pop()); // prints: Philosophy books.push(\"Logic\"); books.push(\"Spanish\"); System.out.println(books.pop()); // prints: Spanish System.out.println(books.pop()); // prints: Logic System.out.println(books.pop()); // prints: CS System.out.println(books.pop()); // throws: \"Out of books!\" } } Then you get some control over what happens when you try to grab a book and it's not there; and you can add methods as your algorithm or data structure grows. The Stack: Method Calls and Recursion Note that computer architecture has the notion of a stack -- in fact, we normally call that notion The Stack . This is a stack in the data structure sense, but it is implemented in a special way and stores a whole bunch of mixed data. In fact, when we call methods or functions, we are pushing that code onto The Stack . When we issue a return statement, we are popping that code from the stack (and maybe pushing the return value!). Stacks are therefore fundamental to how most computer programming languages work -- and we couldn't have most recursive functions (functions that call themselves) without it. Double-Ended Queues (Deques) The Deque<T> interface in Java wraps up data structures for which it is efficient to add or remove from the different sides of a list. LinkedList not only implements Queue but it also implements Deque . As a Deque<T> you get to call the methods: Front Back Returns addFirst addLast void , nothing. removeFirst removeLast T , the item removed. getFirst getLast T , the first/last item. If you want a generic Queue , you can either: addLast and removeFirst or addFirst and removeLast If you want a generic Stack , you can either: addLast and removeLast or addFirst and removeFirst Fancier Queues This section exists as a caveat in case you decide to google around for queue data structures. There are a large class of data structures that are all, broadly, queues and not all of them are relevant to our notion of a queue. Priority Queues Later in this course we will see so-called \"Priority Queues\" (typically implemented as a Heap), which allow you to maintain a queue with importances. For example, the queue to see a professor at office hours is likely to be maintained first by arrival time (FIFO) but students who need to go to another class may petition their classmates to cut in line. Therefore, some sense of urgency or importance is incorporated into the queue. Even using a priority queue is slightly more difficult because you need to be able to sort the elements you put in; therefore, a priority queue is not quite a list. Aside: Comparable for PriorityQueue Another example of a Priority Queue in the real world is a hospital. To use Java's PriorityQueue<T> we need to implement an interface called Comparable<T> -- we haven't discussed interfaces in depth and we will return to Comparable later when we get to sorting. public class Patient implements Comparable<Patient> { long arrivalTime; boolean severe; String name; //... constructor and more methods ... @Override public int compareTo(Patient p) { // severe=true then false int cmp = -Boolean.compare(this.severe, p.severe); if (cmp != 0) return cmp; // earlier times better: cmp = Long.compare(this.arrivalTime, p.arrivalTime); if (cmp != 0) return cmp; // by name if all else equal return this.name.compareTo(p.name); } } Concurrent or Threadsafe Queues In a more advanced programming class or an operating systems class, more subtleties are added to queue design: what happens if two requests come in at the same time? In the dining hall metaphor, the two students arriving at the same time will sort out for themselves which order they should be added to the queue. Elements in our lists are not so intelligent, but some queues are smarter and work to deal with such conflicts without causing the line to end up in disarray. A computer uses an abstraction called threads to run code at the same time, and therefore queues that are safe to use in this environment are called concurrent or threadsafe queues. Java has some of these in its standard library but we will not dicuss them in this course.","title":"\ud83d\udcd6 Stacks & Queues"},{"location":"stacks-and-queues.html#stacks-queues","text":"It turns out that lists are very useful data structures. In fact, people use lists for all sorts of behaviors. Two behaviors are so common that we have given them their own names. We will discuss these behaviors again when we are implementing our own data structures but here we discuss these \"archetypal\" data structures.","title":"Stacks &amp; Queues"},{"location":"stacks-and-queues.html#queues-fifo","text":"Queues are type of list where you are always operating on opposite ends of a list. Imagine you're waiting in line for food at a dining hall or at a restaurant. You see a line of people, and so you add yourself to the back of the line. The dining hall serves people one at a time from the front of the line. You know that eventually you will reach the front. Queue behavior is sometimes referred to as \"First-Come First-Serve\" (FCFS) or \"First-In, First-Out\" (FIFO). Java has a Queue class, and LinkedList is a queue. Queue<String> diningHall = new LinkedList<>(); diningHall.add(\"A\"); diningHall.add(\"B\"); System.out.println(diningHall.remove()); // prints: A diningHall.add(\"C\"); diningHall.add(\"D\"); System.out.println(diningHall.remove()); // prints: B System.out.println(diningHall.remove()); // prints: C System.out.println(diningHall.remove()); // prints: D Note that we could have written this program with diningHall.remove(0) on a regular List<String> . Choosing Queue over List typically means that you know exactly how you are going to use this data structure and it would help readers of your code to know that, too.","title":"Queues (FIFO)"},{"location":"stacks-and-queues.html#stacks-lifo","text":"Stacks are a type of list where you are always operating on the same side. Imagine you take all your textbooks and pile them up on top of your desk. You realize that your computer science book is on the bottom, and your Spanish Language textbook is on top. You decide to do your Spanish homework first, so as not to knock over your stack of books. Stacks allow you to pile up work for later, and get back to it in a \"most-recent\" first manner. Stack behavior is sometimes referred to as \"Last-In, First-Out\" (LIFO) in symmetry to Queues which are FIFO. Java has a Stack class, but they don't recommend it. In fact they recommend the Deque interface, which is more powerful and we will discuss briefly in the next section. You can remove from the back of any list by doing: list.remove(list.size()-1) . List<String> books = new ArrayList<>(); books.add(\"CS\"); books.add(\"Philosphy\"); System.out.println(books.remove(books.size()-1)); // prints: Philosophy books.add(\"Logic\"); books.add(\"Spanish\"); System.out.println(books.remove(books.size()-1)); // prints: Spanish System.out.println(books.remove(books.size()-1)); // prints: Logic System.out.println(books.remove(books.size()-1)); // prints: CS If you really want a stack for your project, it may make sense to write a simple class to handle it: /** Design push/pop for more clear stack-code */ public class StackOfBooks { /** Using an arraylist to build a Stack. */ private List<String> books = new ArrayList<String>(); /** Add a book to the top of the stack */ public void push(String book) { this.books.add(book); } /** Remove a book from the top of the stack */ public String pop() { if (this.books.size() == 0) { throw new IllegalStateException(\"Out of books!\"); } return this.books.remove(this.books.size() - 1); } public static void main(String[] args) { StackOfBooks books = new StackOfBooks(); books.push(\"CS\"); books.push(\"Philosphy\"); System.out.println(books.pop()); // prints: Philosophy books.push(\"Logic\"); books.push(\"Spanish\"); System.out.println(books.pop()); // prints: Spanish System.out.println(books.pop()); // prints: Logic System.out.println(books.pop()); // prints: CS System.out.println(books.pop()); // throws: \"Out of books!\" } } Then you get some control over what happens when you try to grab a book and it's not there; and you can add methods as your algorithm or data structure grows.","title":"Stacks (LIFO)"},{"location":"stacks-and-queues.html#the-stack-method-calls-and-recursion","text":"Note that computer architecture has the notion of a stack -- in fact, we normally call that notion The Stack . This is a stack in the data structure sense, but it is implemented in a special way and stores a whole bunch of mixed data. In fact, when we call methods or functions, we are pushing that code onto The Stack . When we issue a return statement, we are popping that code from the stack (and maybe pushing the return value!). Stacks are therefore fundamental to how most computer programming languages work -- and we couldn't have most recursive functions (functions that call themselves) without it.","title":"The Stack: Method Calls and Recursion"},{"location":"stacks-and-queues.html#double-ended-queues-deques","text":"The Deque<T> interface in Java wraps up data structures for which it is efficient to add or remove from the different sides of a list. LinkedList not only implements Queue but it also implements Deque . As a Deque<T> you get to call the methods: Front Back Returns addFirst addLast void , nothing. removeFirst removeLast T , the item removed. getFirst getLast T , the first/last item. If you want a generic Queue , you can either: addLast and removeFirst or addFirst and removeLast If you want a generic Stack , you can either: addLast and removeLast or addFirst and removeFirst","title":"Double-Ended Queues (Deques)"},{"location":"stacks-and-queues.html#fancier-queues","text":"This section exists as a caveat in case you decide to google around for queue data structures. There are a large class of data structures that are all, broadly, queues and not all of them are relevant to our notion of a queue.","title":"Fancier Queues"},{"location":"stacks-and-queues.html#priority-queues","text":"Later in this course we will see so-called \"Priority Queues\" (typically implemented as a Heap), which allow you to maintain a queue with importances. For example, the queue to see a professor at office hours is likely to be maintained first by arrival time (FIFO) but students who need to go to another class may petition their classmates to cut in line. Therefore, some sense of urgency or importance is incorporated into the queue. Even using a priority queue is slightly more difficult because you need to be able to sort the elements you put in; therefore, a priority queue is not quite a list.","title":"Priority Queues"},{"location":"stacks-and-queues.html#aside-comparable-for-priorityqueue","text":"Another example of a Priority Queue in the real world is a hospital. To use Java's PriorityQueue<T> we need to implement an interface called Comparable<T> -- we haven't discussed interfaces in depth and we will return to Comparable later when we get to sorting. public class Patient implements Comparable<Patient> { long arrivalTime; boolean severe; String name; //... constructor and more methods ... @Override public int compareTo(Patient p) { // severe=true then false int cmp = -Boolean.compare(this.severe, p.severe); if (cmp != 0) return cmp; // earlier times better: cmp = Long.compare(this.arrivalTime, p.arrivalTime); if (cmp != 0) return cmp; // by name if all else equal return this.name.compareTo(p.name); } }","title":"Aside: Comparable for PriorityQueue"},{"location":"stacks-and-queues.html#concurrent-or-threadsafe-queues","text":"In a more advanced programming class or an operating systems class, more subtleties are added to queue design: what happens if two requests come in at the same time? In the dining hall metaphor, the two students arriving at the same time will sort out for themselves which order they should be added to the queue. Elements in our lists are not so intelligent, but some queues are smarter and work to deal with such conflicts without causing the line to end up in disarray. A computer uses an abstraction called threads to run code at the same time, and therefore queues that are safe to use in this environment are called concurrent or threadsafe queues. Java has some of these in its standard library but we will not dicuss them in this course.","title":"Concurrent or Threadsafe Queues"}]}